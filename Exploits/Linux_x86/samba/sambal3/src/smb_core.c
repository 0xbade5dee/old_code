#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>

#include "session.h"

#include "mode.h"
#include "nbt.h"
#include "netio.h"
#include "smb.h"
#include "smb_core.h"
#include "smb_funct.h"
#include "smb_parse.h"
#include "string.h"
#include "wrapper.h"

void
hex_dump(const char *src, size_t len)
{
        size_t i = 0;

        for (i = 0; i < len; i++) {
                if (i % 16 == 0) fprintf(stderr, "\n");
                fprintf(stderr, "%02x.", (unsigned char) src[i]);
        }

        fprintf(stderr, "\n\n");
        return;
}


int
check_smb_header(struct SMB_packet *packet, int expected_command)
{
        if (packet->SMB_protocol[0] != 0xff)
                return -1;
        
        if (packet->SMB_protocol[1] != 'S')
                return -1;

        if (packet->SMB_protocol[2] != 'M')
                return -1;

        if (packet->SMB_protocol[3] != 'B')
                return -1;

        if (packet->SMB_command != expected_command) 
                return -1;
        
        if (packet->SMB_status != 0)
                return -1;

        return 0;
}

int
recv_packet(    struct SMB_session      *session,
                int                     expected_command)
{
        struct SMB_packet packet;

        char recv_buf[MAX_BUFSIZE];

        uint16_t bcc[3] = { 0, 0, 0 };

        int ret = 0;

        memset(recv_buf, '\0', sizeof(recv_buf));

        if ((ret = netio_recv(session->fd, recv_buf, sizeof(recv_buf), 0)) < 0) {
                /* Do error handling. */
                return -1;
        }

        if (ret < sizeof(struct SMB_packet)) {
                /* Do error handling. */
                return -1;
        }

        memcpy(&packet, recv_buf, sizeof(struct SMB_packet));

        if (MODE_IS_SET(MODE_VERBOSE)) {
                fprintf(stdout, "recv_packet: command received: 0x%02x\r\n", packet.SMB_command);
        }

        if (packet.NBT_type != NB_SSN_MESSAGE) {
                /* Do error handling. */
                return -1;
        }

        if (check_smb_header(&packet, expected_command) < 0) {
                /* Do error handling. */
                return -1;
        }

        if (packet.SMB_uid != 0) session->uid = packet.SMB_uid;
        
        bcc[0] = *(recv_buf + sizeof(packet) - 1 + (packet.SMB_wct * 2));
        bcc[1] = *(recv_buf + sizeof(packet) - 0 + (packet.SMB_wct * 2));       
        bcc[2] = (bcc[1] << 8) + bcc[0]; 

        session->wct_length     = packet.SMB_wct;
        session->bcc_length     = bcc[2];
        session->cmd            = packet.SMB_command;
        session->tid            = packet.SMB_tid;
        session->pid            = packet.SMB_pid;
        session->uid            = packet.SMB_uid;
        session->mid            = packet.SMB_mid;

        if (session->wct_length) {

                if ((sizeof(packet) + (session->wct_length * 2)) > sizeof(recv_buf) - 1)
                        return -1;

                session->wct_data = xmalloc(session->wct_length * 2);

                memcpy(session->wct_data, recv_buf + sizeof(packet) - 1, session->wct_length * 2);
        }

        if (session->bcc_length) {

                if ((sizeof(packet) + session->bcc_length) > sizeof(recv_buf) - 1)
                        return -1;

                session->bcc_data = xmalloc(session->bcc_length);

                memcpy(session->bcc_data, recv_buf + sizeof(packet) - 1 + (session->wct_length * 2) + 2, session->bcc_length);
        }

        if (packet.SMB_command == SMBtrans) {
                if (parse_rpc_header(session, session->bcc_data, session->bcc_length) < 0) {
                        session->rpc_type       = -1;
                        session->rpc_status     = -1;
                }
        }

        return 0;
}

int
send_packet(    struct SMB_session      *session, 
                int                     command, 
                uint8_t                 wct, 
                char                    *wct_data,
                uint16_t                bcc,
                char                    *bcc_data)
{
        char send_buf[MAX_BUFSIZE];
        
        u_int32_t length        = 0;

        length = build_packet(  send_buf, 
                                sizeof(send_buf),
                                command,
                                session->flags,
                                session->flags2,
                                session->tid,
                                session->pid,
                                session->uid,
                                session->mid,
                                wct,
                                wct_data,
                                bcc,
                                bcc_data);

        if (MODE_IS_SET(MODE_VERBOSE)) {
                fprintf(stdout, "VERBOSE: sending packet: command: 0x%02x, wct: %u, bcc: %u, total length: %u\r\n",
                                command, wct, bcc, length);
        }

        return netio_send(session->fd, send_buf, length, 0);
}

int
build_packet(           char            *buffer,
                        size_t          length,
                        uint8_t         command,
                        uint8_t         flags,
                        uint16_t        flags2,
                        uint16_t        tid,
                        uint16_t        pid,
                        uint16_t        uid,
                        uint16_t        mid,
                        uint8_t         wct,
                        char            *wct_data,
                        uint16_t        bcc,
                        char            *bcc_data)
{
        struct SMB_packet packet;

        memset(&packet, '\0', sizeof(packet));
        memset(buffer,  '\0', length);

        packet.SMB_protocol[0]  = 0xff;
        packet.SMB_protocol[1]  = 'S';
        packet.SMB_protocol[2]  = 'M';
        packet.SMB_protocol[3]  = 'B';
        packet.SMB_command      = command;
        packet.SMB_status       = 0;
        packet.SMB_reserved     = 0;
        packet.SMB_flags        = flags;
        packet.SMB_flags2       = flags2;
        packet.SMB_tid          = tid;
        packet.SMB_pid          = pid;
        packet.SMB_uid          = uid;
        packet.SMB_mid          = mid;
        packet.SMB_wct          = wct;

        packet.NBT_type         = NB_SSN_MESSAGE;
        packet.NBT_flags        = 0;
        packet.NBT_length       = htons(sizeof(packet) - 3 + (wct * 2) + bcc);

        memcpy(buffer, (const char *)&packet, sizeof(packet));

        if (sizeof(packet) + (wct * 2) + 4 + bcc > length) {
                fprintf(stderr, "build_packet: corrupted word/byte count?\r\n");
                exit(EXIT_FAILURE);
        }
        
        if (wct) {
                memcpy(buffer + sizeof(packet) - 1, wct_data, wct * 2);
        }

        if (bcc) {
                memcpy(buffer + sizeof(packet) - 1 + (wct * 2) + 2, bcc_data, bcc);
        }

        memcpy(buffer + sizeof(packet) - 1 + (wct * 2), &bcc, 2);

        return ntohs(packet.NBT_length) + 4;
}

/* byte count/word count functions. */

void
add_bcc_uint8_t(struct bcc_struct *data_structure, uint8_t value)
{
        *(data_structure->data + data_structure->count) = value;

        data_structure->count++;

        return;
}

void
add_bcc_uint16_t(struct bcc_struct *data_structure, uint16_t value)
{
        *((uint16_t *)(data_structure->data + data_structure->count)) = value;

        data_structure->count   += 2;

        return;
}

void
add_bcc_uint32_t(struct bcc_struct *data_structure, uint32_t value)
{
        add_bcc_uint16_t(data_structure, value & 0xffff);
        add_bcc_uint16_t(data_structure, (value >> 16));

        return;
}


void
add_wct_uint8_t(struct wct_struct *data_structure, uint8_t value)
{
        *((uint8_t *)data_structure->data + data_structure->count) = value;

        data_structure->count++;        
        data_structure->offset++;

        return;
}

void
add_wct_uint16_t(struct wct_struct *data_structure, uint16_t value)
{
        *((uint16_t *)(data_structure->data + data_structure->offset)) = value;

        data_structure->count   += 1;
        data_structure->offset  += 2;

        return;
}

void
add_wct_uint32_t(struct wct_struct *data_structure, uint32_t value)
{
        add_wct_uint16_t(data_structure, value & 0xffff);
        add_wct_uint16_t(data_structure, (value >> 16));

        return;
}


void
add_bcc_string(struct bcc_struct *data_structure, char *string)
{
        strcpy(data_structure->data + data_structure->count, string);

        data_structure->count   += (strlen(string) + 1);

        return;
}

void
init_bcc_struct(struct bcc_struct *data_structure)
{
        data_structure->data    = xmalloc(DEFAULT_STRUCT_SIZE);
        data_structure->count   = 0;
        
        return;
}

void
init_wct_struct(struct wct_struct *data_structure)
{
        data_structure->data    = xmalloc(DEFAULT_STRUCT_SIZE);
        data_structure->count   = 0;
        data_structure->offset  = 0;

        return;
}

void
free_bcc_struct(struct bcc_struct *data_structure)
{
        if (data_structure->data) free(data_structure->data);

        return;
}

void
free_wct_struct(struct wct_struct *data_structure)
{
        if (data_structure->data) free(data_structure->data);

        return;
}

void
free_data_session(struct SMB_session *session)
{
        if (session->wct_data) free(session->wct_data);
        if (session->bcc_data) free(session->bcc_data);
        
        session->wct_data = NULL;
        session->bcc_data = NULL;

        return;
}

