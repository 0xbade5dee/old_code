/*
 .oooooo..o                              .o8                 oooo       ooooo ooooo ooooo
d8P'    `Y8                             "888                 `888       `888' `888' `888'
Y88bo.       .oooo.   ooo. .oo.  .oo.    888oooo.   .oooo.    888        888   888   888
 `"Y8888o.  `P  )88b  `888P"Y88bP"Y88b   d88' `88b `P  )88b   888        888   888   888
     `"Y88b  .oP"888   888   888   888   888   888  .oP"888   888        888   888   888
oo     .d8P d8(  888   888   888   888   888   888 d8(  888   888        888   888   888
8""88888P'  `Y888""8o o888o o888o o888o  `Y8bod8P' `Y888""8o o888o      o888o o888o o888o

  sambal III: samba 3.x.x remote root exploit                  by eSDee (esdee@netric.org)

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <signal.h>
#include "session.h"

#include "ansi.h"
#include "scan.h"
#include "cidr.h"
#include "mode.h"
#include "ports.h"
#include "netio.h"
#include "smb_funct.h"

void
SMB_scan_inthandler(void)
{
        fprintf(stdout, NO"\r\n");
        exit(EXIT_FAILURE);
}

void
SMB_scan_network(struct SMB_session *session, const char *network, unsigned int mask)
{

        struct sockaddr_in      dest;
        struct sockaddr_in      from;

        struct ifreq            ifr;

        int fd[2] = { 0, 0 };

        unsigned long start     = 0;
        unsigned long end       = 0;
        unsigned long current   = 0;

        memset(&dest,   '\0', sizeof(struct sockaddr_in));
        memset(&from,   '\0', sizeof(struct sockaddr_in));
        memset(&ifr,    '\0', sizeof(struct ifreq));

        signal(SIGINT, (void *)SMB_scan_inthandler);

        if (!MODE_IS_SET(MODE_MANUAL_PORT)) {
                if (MODE_IS_SET(MODE_NBT)) 
                        session->port = NBT_PORT;
                else if(MODE_IS_SET(MODE_SMB))
                        session->port = SMB_PORT;
        }

        start   = cidr_convert_ip(network);
        end     = cidr_add_masking(network, mask);

        fd[0] = netio_get_sock(IPPROTO_RAW);
        fd[1] = netio_get_sock(IPPROTO_TCP);

        strncpy(ifr.ifr_name, session->device, sizeof(ifr.ifr_name) - 1);

        if (ioctl(fd[0], SIOCGIFADDR, &ifr) < 0) {
                fprintf(stderr, "SMB_scan_network: Unable to get the IP address from device \"%s\"\n", session->device);
                exit(EXIT_FAILURE);
        }

        memcpy(&from, &ifr.ifr_addr, sizeof(struct sockaddr_in));

        from.sin_port = htons(1024);

        fprintf(stdout, GR"["LG"!"GR"] "DG"Scanning "LG"%s"DG"/"LG"%u"DG" ... \r\n"NO, network, mask);

        for (current = start; current <= end; current++) {

                memset(&dest, '\0', sizeof(struct sockaddr_in));

                dest.sin_family = AF_INET;
                dest.sin_port   = htons(session->port);

                if (inet_aton(cidr_reverse_int(current), &dest.sin_addr) == 0) {
                        fprintf(stderr, "inet_aton: Invalid address.\n");
                        exit(EXIT_FAILURE);
                }

                netio_send_packet(fd[0], &dest, &from, TH_SYN, 100);
                netio_recv_packet(fd[1], &dest, &from, time_out);

                usleep(1000);

        }

        sleep(2);

        netio_recv_packet(fd[1], &dest, &from, time_out);

        close(fd[0]);
        close(fd[1]);

        return;
}

void
scan_host_found(char *ip_address, unsigned int port)
{
        struct SMB_session session;

        memset(&session, '\0', sizeof(struct SMB_session));

        session.hostname        = ip_address;
        session.port            = port;

        if (SMB_connect(&session) < 0) {
                fprintf(stdout, GR" -  "DR"%s"GR":"DR"%u"GR" - "LR"Unable to reconnect.\r\n"NO, ip_address, port);
                SMB_free_session(&session);
                return;
        }

        if (SMB_establish_null_session(&session) < 0) {
                SMB_free_session(&session);
                fprintf(stdout, GR" -  "DR"%s"GR":"DR"%u"GR" - "LR"Unable to establish null session to $IPC\r\n"NO, ip_address, port);
                return;
        }

        if (session.native_lm && session.native_os) {

                if (!strncmp(session.native_lm, "Windows", 7)) {
                        fprintf(stdout, GR" -  "DC"%s"GR":"DC"%u "GR"-"LC" %s (%s)\r\n"NO, ip_address, port, session.native_os, session.native_lm);
                } else if (!strncmp(session.native_lm, "Samba", 5)) {
                        SMB_receive_share_comment(&session, "IPC$");

                        if (session.share_comment)
                                fprintf(stdout, GR" -  "DG"%s"GR":"DG"%u "GR"-"LG" %s (%s) "GR"["LG"%s"GR"]\r\n"NO,
                                                ip_address, port, session.native_os, session.native_lm, session.share_comment);
                        else
                                fprintf(stdout, GR"["LG"!"GR"] "DG"%s"GR":"DG"%u "GR"-"LG" %s (%s) "GR"["LG"Unknown"GR"]\r\n"NO,
                                                ip_address, port, session.native_os, session.native_lm);
                } else {
                        fprintf(stdout, GR" -  "DB"%s"GR":"DB"%u "GR"-"LB" %s (%s)\r\n"NO, ip_address, port, session.native_os, session.native_lm);
                }
        }  else {

                fprintf(stdout, GR" -  "DB"%s"GR":"DB"%u "GR"-"LB" Unknown operating system.\r\n"NO, ip_address, port);
        }


        SMB_free_session(&session);

        return;
}
