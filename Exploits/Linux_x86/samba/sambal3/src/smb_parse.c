/*
 .oooooo..o                              .o8                 oooo       ooooo ooooo ooooo
d8P'    `Y8                             "888                 `888       `888' `888' `888'
Y88bo.       .oooo.   ooo. .oo.  .oo.    888oooo.   .oooo.    888        888   888   888
 `"Y8888o.  `P  )88b  `888P"Y88bP"Y88b   d88' `88b `P  )88b   888        888   888   888
     `"Y88b  .oP"888   888   888   888   888   888  .oP"888   888        888   888   888
oo     .d8P d8(  888   888   888   888   888   888 d8(  888   888        888   888   888
8""88888P'  `Y888""8o o888o o888o o888o  `Y8bod8P' `Y888""8o o888o      o888o o888o o888o

  sambal III: samba 3.x.x remote root exploit                  by eSDee (esdee@netric.org)

*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>

#include "session.h"

#include "rpc.h"
#include "smb_funct.h"
#include "smb_parse.h"
#include "wrapper.h"

void
dump_data(FILE *stream, const char *buffer, size_t length)
{
        int i = 0;

        for (i = 0; i < length; i++) {

                if (i % 32 == 0) 
                        fprintf(stream, "\r\n");

                fprintf(stream, "%02x.", (unsigned char) buffer[i]);
        }

        fprintf(stream, "\r\n\r\n");

        return;
}

int
parse_pipe_handle(struct SMB_session *session, const char *buffer, size_t length)
{
        unsigned int pipe_handle[2] = { 0, 0 };

        if (length < 6) 
                return -1;

        pipe_handle[0] = *((unsigned char *)buffer + 5);
        pipe_handle[1] = *((unsigned char *)buffer + 6);

        session->pipe_handle = (pipe_handle[1] << 8) + pipe_handle[0];

        return 0;
}

void
parse_native_information(struct SMB_session *session, const char *buffer, size_t length)
{
        char *native_os = NULL;
        char *native_lm = NULL;
        char *prim_dom  = NULL;

        if (!buffer || !length) 
                return;

        native_os       = (char *)buffer;

        if ((native_os + strlen(native_os)) >= (buffer + length)) 
                return;

        native_lm       = native_os + strlen(native_os) + 1;

        if ((native_lm + strlen(native_lm)) >= (buffer + length)) 
                return;

        prim_dom        = native_lm + strlen(native_lm) + 1;

        if ((prim_dom + strlen(prim_dom)) >= (buffer + length)) 
                return;

        session->native_lm              = xstrdup(native_lm);
        session->native_os              = xstrdup(native_os);
        session->primary_domain         = xstrdup(prim_dom);
                
        return;
}

int
parse_rpc_header(struct SMB_session *session, const char *buffer, size_t length)
{
        struct RPC_response response;

        memset(&response, '\0', sizeof(struct RPC_response));

        if (!buffer || !length)
                return -1;

        if ((length - 1) < sizeof(struct RPC_response))
                return -1;

        memcpy(&response, buffer + 1, sizeof(struct RPC_response));

        session->rpc_type       = response.pkt_type;
        session->rpc_status     = response.status;

        return 0;
}

int
parse_policy_handle(struct SMB_session *session)
{
        if (!session->bcc_data)
                return -1;

        if (!session->bcc_length)
                return -1;
        
        if (session->bcc_length < (sizeof(struct policy_handle) + 25))
                return -1;

        memcpy(&session->pol_handle, session->bcc_data + 25, sizeof(struct policy_handle));
        
        return 0;
}

int
parse_share_comment(struct SMB_session *session, const char *buffer, size_t length)
{
        char buf[1024];

        int i = 0;

        if (length < 90)
                return -1;

        memset(buf, '\0', sizeof(buf));

        strncpy(buf, buffer + 77 + strlen("IPC Service ("), sizeof(buf) - 1);

        for (i = strlen(buf); i > 0; i--) {
                if (buf[i] == ')') {
                        buf[i] = '\0';
                        break;
                }
        }

        session->share_comment = strdup(buf);

        if (!session->share_comment) {
                perror("strdup");
                exit(EXIT_FAILURE);
        }

        return 0;
}

