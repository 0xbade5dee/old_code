#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#include "session.h"

#include "mode.h"
#include "nbt.h"
#include "netio.h"
#include "ports.h"
#include "rpc.h"
#include "smb.h"
#include "smb_funct.h"
#include "wrapper.h"

int
SMB_connect(struct SMB_session *session)
{
        if (MODE_IS_SET(MODE_MANUAL_PORT)) {
                session->fd = netio_connect(session->hostname, session->port);
        } 
        else {
                if (MODE_IS_SET(MODE_NBT)) 
                        session->fd = netio_connect(session->hostname, NBT_PORT);
                else if (MODE_IS_SET(MODE_SMB))
                        session->fd = netio_connect(session->hostname, SMB_PORT);
        }

        if (session->fd < 0) 
                return -1;

        if (MODE_IS_SET(MODE_NBT)) {

                session->nbt_name = "*SMBSERVER";

                if (NBT_session_setup(session) < 0) {
                        fprintf(stderr, "SMB_connect: session setup fails.\r\n");
                        return -1;
                }
        }

        return 0;
}

void
SMB_free_session(struct SMB_session *session)
{
        if (session->fd)
                close(session->fd);
        if (session->native_lm)
                free(session->native_lm);
        if (session->native_os)
                free(session->native_os);
        if (session->primary_domain);
                free(session->primary_domain);
        if (session->wct_data)
                free(session->wct_data);
        if (session->bcc_data)
                free(session->bcc_data);
        if (session->device)
                free(session->device);
        if (session->share_comment)
                free(session->share_comment);
                
        session->native_lm              = NULL;
        session->native_os              = NULL;
        session->primary_domain         = NULL;
        session->wct_data               = NULL;
        session->bcc_data               = NULL;
        session->device                 = NULL;
        session->share_comment          = NULL;
        
        return;
}

int
SMB_establish_null_session(struct SMB_session *session)
{
        u_char service[1024];

        session->tid    = 0;
        session->pid    = 0;
        session->uid    = 0;
        session->mid    = 1;
        session->flags  = 0;
        session->flags2 = 0;

        if (negotiate_dialect(session) < 0) 
                return -1;

        if (session_setup_request(session) < 0)
                return -1;

/*
        if (session_setup_request_NTLMSSP(session) < 0)
                return -1;

        if (session_setup_request_AUTH(session) < 0)
                return -1;
*/

        snprintf(service, sizeof(service), "\\\\%s\\IPC$", session->hostname);

        if (tree_connect_and_x_reply(session, service) < 0)
                return -1;

        return 0;
}

int
SMB_rpc_bind(struct SMB_session *session, struct RPC_session *rpc_session)
{
        struct rpc_uuid uuid;
        struct rpc_uuid syntax;

        char *rpc_buf = xmalloc(1024);

        if (nt_open_pipe(session, rpc_session->pipe_name) < 0) {
                free(rpc_buf);
                return -1;
        }

        RPC_build_interface_uuid(       rpc_session->uuid,
                                        rpc_session->syntax,
                                        (struct rpc_uuid *)&uuid,
                                        (struct rpc_uuid *)&syntax);

        RPC_build_bind_request(         rpc_buf, 
                                        1024, 
                                        &uuid, 
                                        &syntax, 
                                        rpc_session->uuid_ver_major, 
                                        rpc_session->uuid_ver_minor);

        if (do_trans(session, rpc_buf, FRAG_LEN, "\\PIPE\\", TRANSACT_DCERPCCMD) < 0) {
                free(rpc_buf);
                return -1;
        }

        free(rpc_buf);

        return 0;
}

int
SMB_receive_share_comment(struct SMB_session *session, char *share_name)
{
        char rap_buf[4096];
        char *ptr = (char *)&rap_buf;

        memset(&rap_buf, '\0', sizeof(rap_buf));

        rap_buf[0] = RAP_WshareGetInfo;
        rap_buf[1] = 0;

        ptr = &rap_buf[2];

        strcpy(ptr, "zWrLh");
        ptr += strlen("zWrLh") + 1;

        strcpy(ptr, "B13BWzWWWzB9BB9BWzWWzWW");
        ptr += strlen("B13BWzWWWzB9BB9BWzWWzWW") + 1;

        strcpy(ptr, share_name);
        ptr += strlen(share_name) + 1;

        memcpy(ptr, "\x5B\x00", 2);

        if (do_trans_RAP(session, (char *)&rap_buf, sizeof(rap_buf)) < 0) {
                return -1;
        }

        return 0;
}

int
SMB_rpc(struct SMB_session *session, unsigned int code, char *data, size_t length)
{
        char *rpc_buf = xmalloc(1024 + length);

        size_t len = 0;

        len = RPC_build_request(        rpc_buf,
                                        1024 + length,
                                        (FRAG_LEN / 2) + length,
                                        code,                                       
                                        data, length);
        
        if (do_trans(session, rpc_buf, len, "\\PIPE\\", TRANSACT_DCERPCCMD) < 0) {
                free(rpc_buf);
                return -1;
        }

        free(rpc_buf);

        return 0;
}

