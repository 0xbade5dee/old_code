#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>

#if defined ( __FreeBSD__ )
#include <sys/select.h>
#include <unistd.h>
#include <netinet/in.h>
#endif

#include "session.h"

#include "netio.h"
#include "mode.h"
#include "scan.h"
#include "wrapper.h"

int 
netio_connect(const char *hostname, unsigned short port) 
{
        struct hostent *he =  NULL; 

        struct sockaddr_in saddr;

        int fd          = 0;
        int flags       = 0;
        int ret         = 0;

        if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
                perror("socket");
                exit(EXIT_FAILURE);
        }

        if ((flags = fcntl(fd, F_GETFL, 0)) == -1) {
                perror("fcntl");
                exit(EXIT_FAILURE);
        }

        if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
                perror("fcntl");
                exit(EXIT_FAILURE);
        }

        if ((he = gethostbyname(hostname)) == NULL) {
                return -1;
        }

        memset((char *)&saddr, '\0', sizeof(saddr));
        memcpy((char *)&saddr.sin_addr, he->h_addr, he->h_length);

        saddr.sin_family = AF_INET;
        saddr.sin_port   = htons(port);

        if (MODE_IS_SET(MODE_VERBOSE)) {
                fprintf(stdout, "VERBOSE: xconnect: %s resolved to %s.\r\n", hostname, inet_ntoa(saddr.sin_addr));
        }

        ret = connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));

        if (ret < 0) {
                if (errno != EINPROGRESS) {
                        perror("connect");
                        exit(EXIT_FAILURE);
                }
                else {
                        int n  = 0;
                        struct timeval tv = { 0, time_out };
                        fd_set rset, wset;

                        FD_ZERO(&rset);
                        FD_ZERO(&wset);
                        FD_SET(fd, &rset);
                        FD_SET(fd, &wset);

                        if ((n = select(fd + 1, &rset, &wset, NULL, &tv)) == -1 ) {
                              perror("select");
                              exit(EXIT_FAILURE);
                        }

                        if (n == 0) {
                                return -1;
                        }

                        if (FD_ISSET(fd, &rset) || FD_ISSET(fd, &wset)) {
                                int error = 0 ;
                                int len = sizeof(error);

                                if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &error, &len) == -1) {
                                      perror("getsockopt");
                                      exit(EXIT_FAILURE);
                                }

                                if (error != 0) {
                                        return -1;
                                }

                        }
                        else {
                                return -1;
                        }

                }
        }

        if (fcntl(fd, F_SETFL, flags) == -1) {
                perror("fcntl");
                exit(EXIT_FAILURE);
        }
        else
                return fd;
}

int 
netio_send(int fd, void *buf, size_t len, int flags)
{
        size_t pos = 0;
        ssize_t res;

        while (len > pos) {
                res = send(fd, buf + pos, len - pos, flags);

                switch (res) {
                        case -1:
                                if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) continue;
                                return -1;
                        case 0:
                                errno = EPIPE;
                                return pos;
                        default:
                                pos += (u_int)res;
                }
        }

        return (pos);
}

int
netio_recv(int fd, void *buf, size_t len, int flags)
{
        struct timeval timeout;

        int n   = 0;
        int ret = 0;

        fd_set fdread;

        FD_ZERO(&fdread);
        FD_SET(fd, &fdread);

        timeout.tv_sec  = 0;
        timeout.tv_usec = time_out;

        memset(buf, '\0', len);

        while (1) {

                ret = select(FD_SETSIZE, &fdread, NULL, NULL, &timeout);

                if (ret < 0) {
                        fprintf(stdout, "netio_recv: Connection closed!\r\n");
                        return -1;
                }

                if (ret == 0) {
                        // fprintf(stdout, "netio_recv: Timeout!\r\n");
                        return -1;
                }

                if(FD_ISSET(fd, &fdread)) {
                        if ((n = recv(fd, buf, len, flags)) < 0) return -1;
                        return n;
                }
        }

        return -1;
}

int
netio_bind_socket(unsigned short port)
{
        struct sockaddr_in saddr;

        int fd          = 0;
        int opt         = 1;

        if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
                perror("socket");
                exit(EXIT_FAILURE);
        }
        
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
                perror("setsockopt");
                exit(EXIT_FAILURE);             
        }
        
        memset((void *)&saddr, '\0', sizeof(struct sockaddr_in));

        saddr.sin_family      = AF_INET;
        saddr.sin_addr.s_addr = htonl(INADDR_ANY);
        saddr.sin_port        = htons(port);

        if (bind(fd, (struct sockaddr *) &saddr, sizeof(saddr)) < 0) {
                perror("bind");
                exit(EXIT_FAILURE);
        }

        if (listen(fd, BACKLOG) < 0) {
                perror("listen");
                exit(EXIT_FAILURE);
        }       

        fprintf(stdout, "[!] Listening for incoming connections on: %s:%u\r\n\r\n",
                        inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));

        return fd;
}

int
netio_accept(int fd, struct SMB_session *session)
{
        struct sockaddr_in saddr;

        int new_fd      = 0;
        int saddr_len   = sizeof(struct sockaddr_in);   

        memset((void *)&saddr, '\0', sizeof(struct sockaddr_in));

        if ((new_fd = accept(fd, (struct sockaddr *) &saddr, &saddr_len)) < 0) {
                perror("accept");
                exit(EXIT_FAILURE);
        }

        session->hostname = xstrdup(inet_ntoa(saddr.sin_addr));

        return new_fd;
}

int
netio_send_packet(int fd, struct sockaddr_in *dest, struct sockaddr_in *from, unsigned char session_flags, unsigned long sequence)
{
        struct iphdr        *ip_header          = NULL;
        struct tcphdr       *tcp_header         = NULL;
        struct pseudohdr    *pseudo_header      = NULL;

        char                send_buf[40];
        int                 send_length;
        int                 sent_length;

        memset(send_buf, '\0', sizeof(send_buf));

        ip_header     = (struct iphdr *)send_buf;
        tcp_header    = (struct tcphdr *)(send_buf + sizeof(struct iphdr));
        pseudo_header = (struct pseudohdr *)((char*)tcp_header - sizeof(struct pseudohdr));

        pseudo_header->saddr     = from->sin_addr.s_addr;
        pseudo_header->daddr     = dest->sin_addr.s_addr;
        pseudo_header->protocol  = IPPROTO_TCP;
        pseudo_header->tcplength = htons(sizeof(struct tcphdr));

        tcp_header->th_sport = from->sin_port;
        tcp_header->th_dport = dest->sin_port;
        tcp_header->th_off   = 5;
        tcp_header->th_flags = session_flags;
        tcp_header->th_seq   = htonl(sequence);
        tcp_header->th_ack   = htonl(0);
        tcp_header->th_win   = htons(0x1000);
        tcp_header->th_sum   = in_cksum((uint16_t *)pseudo_header, sizeof(struct pseudohdr) + sizeof(struct tcphdr));

        memset(send_buf, '\0', sizeof(struct iphdr));

        ip_header->saddr    = from->sin_addr.s_addr;
        ip_header->daddr    = dest->sin_addr.s_addr;
        ip_header->version  = 4;
        ip_header->ihl      = 5;
        ip_header->ttl      = 255;
        ip_header->id       = 0xb0ef;
        ip_header->protocol = IPPROTO_TCP;
        ip_header->tot_len  = htons(sizeof(struct iphdr) + sizeof(struct tcphdr));
        ip_header->check    = in_cksum((uint16_t *)ip_header, sizeof(struct iphdr));

        send_length = sizeof(struct iphdr) + sizeof(struct tcphdr);
        sent_length = sendto(fd, send_buf, send_length, 0, (struct sockaddr *)dest, sizeof(struct sockaddr));

        if (send_length != sent_length) return -1;
                else
        return 0;
}

int
netio_get_sock(int type)
{
        int fd = 0;

        if ((fd = socket(AF_INET, SOCK_RAW, type)) < 0) {
                perror("socket");
                exit(EXIT_FAILURE);
        }

        return fd;
}

int
netio_recv_packet(int fd, struct sockaddr_in *dest, struct sockaddr_in *from, int delay_val)
{
        struct timeval          timeout;
        struct sockaddr_in      response;
        struct iphdr            *ip_header          = NULL;
        struct tcphdr           *tcp_header         = NULL;

        char recv_buf[4096];

        int n                   = 0;
        int ret                 = 0;
        int response_len        = sizeof(struct sockaddr_in);

        fd_set fdread;

        ip_header       = (struct iphdr *)recv_buf;
        tcp_header      = (struct tcphdr *)(recv_buf + sizeof(struct iphdr));

        FD_ZERO(&fdread);
        FD_SET(fd, &fdread);

        timeout.tv_sec  = 0;
        timeout.tv_usec = delay_val;

        memset(recv_buf,  '\0', sizeof(recv_buf));
        memset(&response, '\0', sizeof(struct sockaddr_in));

        while (1) {

                ret = select(FD_SETSIZE, &fdread, NULL, NULL, &timeout);

                if (ret < 0) {
                        perror("select");
                        exit(EXIT_FAILURE);
                }

                if (ret == 0) return -1;

                if(FD_ISSET(fd, &fdread)) {
                                
                        if ((n = recvfrom(fd, recv_buf, sizeof(recv_buf), 0, (struct sockaddr *)&response, &response_len))  < 0) {
                                perror("recv");
                                exit(EXIT_FAILURE);
                        }

                        if (tcp_header->th_sport != dest->sin_port) {
                                return -1;
                        }

                        if (tcp_header->th_dport != from->sin_port) {
                                return -1;
                        }

                        if (    (tcp_header->th_flags & TH_SYN) &&
                                (tcp_header->th_flags & TH_ACK)) {
                                        netio_send_packet(fd, from, &response, TH_RST, 101);
                                        scan_host_found(inet_ntoa(response.sin_addr), ntohs(tcp_header->th_sport));

                        }

                        return n;
                }

        }

        return 0;

}

unsigned short
in_cksum(uint16_t *addr, int len)
{
        int             sum     = 0;
        int             nleft   = len;

        uint16_t        *w      = addr;
        uint16_t        answer  = 0;

        while (nleft > 1){
                sum += *w++;
                nleft -= 2;
        }

        if (nleft == 1){
                *(uint8_t *)(&answer) = *(uint8_t *)w ;
                sum += answer;
        }

        sum = (sum >> 16) + (sum & 0xffff);
        sum += (sum >> 16);

        answer = ~sum;
        return(answer);
}

void
netio_handle_shell(int fd)
{
        unsigned char recv_buf[4096];

        int n   = 1;
        int ret = 0;

        fd_set fds;

        memset(recv_buf, '\0', sizeof(recv_buf));

        while(n) {
                FD_ZERO(&fds);
                FD_SET(0, &fds);
                FD_SET(fd, &fds);

                ret = select(FD_SETSIZE, &fds, NULL, NULL, NULL);

                if (ret < 0) {
                        close(fd);
                        perror("select");
                        exit(EXIT_FAILURE);
                }

                if (FD_ISSET(STDIN_FILENO, &fds)) {

                        if((n = read(STDIN_FILENO, recv_buf, sizeof(recv_buf))) < 1) {
                                if(errno == EWOULDBLOCK || errno == EAGAIN)
                                        continue;
                                else
                                        break;
                        }

                        if((n = write(fd, recv_buf, n)) < 1) {
                                if(errno == EWOULDBLOCK || errno == EAGAIN)
                                        continue;
                                else
                                        break;
                        }
                }

                if (FD_ISSET(fd, &fds)) {
                        if((n = read(fd, recv_buf, sizeof(recv_buf))) < 1) {
                                if(errno == EWOULDBLOCK || errno == EAGAIN)
                                        continue;
                                else
                                        break;
                        }

                        if((n = write(STDOUT_FILENO, recv_buf, n)) < 1) {
                                if(errno == EWOULDBLOCK || errno == EAGAIN)
                                        continue;
                                else
                                        break;
                        }

                }

        }

        fprintf(stdout, "\r\n[!] Connection closed.\r\n");

        close(fd);
        exit(EXIT_FAILURE);
}

