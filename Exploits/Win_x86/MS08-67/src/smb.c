#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>

#include "session.h"

#include "mode.h"
#include "smb.h"
#include "smb_core.h"
#include "smb_funct.h"
#include "smb_parse.h"

int
negotiate_dialect(struct SMB_session *session)
{
        struct bcc_struct bcc_struct;

        init_bcc_struct(&bcc_struct);

        add_bcc_uint8_t (&bcc_struct,   0x02);
        add_bcc_string  (&bcc_struct,   "MICROSOFT NETWORKS 1.03");
        add_bcc_uint8_t (&bcc_struct,   0x02);
        add_bcc_string  (&bcc_struct,   "MICROSOFT NETWORKS 3.0");
        add_bcc_uint8_t (&bcc_struct,   0x02);
        add_bcc_string  (&bcc_struct,   "LANMAN1.0");
        add_bcc_uint8_t (&bcc_struct,   0x02);
        add_bcc_string  (&bcc_struct,   "LM1.2X002");
        add_bcc_uint8_t (&bcc_struct,   0x02);
        add_bcc_string  (&bcc_struct,   "NT LM 0.12");
        add_bcc_uint8_t (&bcc_struct,   0x02);
        add_bcc_string  (&bcc_struct,   "NT LANMAN 1.0");
                
        if (send_packet(session, SMBnegprot, 0, NULL, bcc_struct.count, bcc_struct.data) < 0) 
                return -1;

        free_bcc_struct(&bcc_struct);
        
        if (recv_packet(session, SMBnegprot) < 0)
                return -1;

        free_data_session(session);
        
        return 0;
}

int
session_setup_request(struct SMB_session *session)
{
        struct bcc_struct bcc_struct;
        struct wct_struct wct_struct;

        init_bcc_struct(&bcc_struct);
        init_wct_struct(&wct_struct);

        session->flags  = 0x08;
        session->flags2 = 0x4001;

        add_wct_uint16_t(&wct_struct,   0xff);          // AndXCommand, no more commands.
        add_wct_uint16_t(&wct_struct,   0);             // andXOffset.
        add_wct_uint16_t(&wct_struct,   1024);          // maxBufferCount.
        add_wct_uint16_t(&wct_struct,   50);            // maxMpxCount.
        add_wct_uint16_t(&wct_struct,   0);             // setup_new_vc_session.
        add_wct_uint32_t(&wct_struct,   0);             // Session-key.

        add_wct_uint16_t(&wct_struct,   0);    // ANSI pass length.

        add_wct_uint16_t(&wct_struct,   0);             // Unicode pass length.
        add_wct_uint32_t(&wct_struct,   0);             // Reserved.
        add_wct_uint32_t(&wct_struct,   0);             // Capabilities.

        if (session->username)
                add_bcc_string  (&bcc_struct,   session->username);     // Username.
        else
                add_bcc_string  (&bcc_struct,   "");                    // None.

        if (session->remote_dom)
                add_bcc_string  (&bcc_struct, session->remote_dom);     // Domain.
        else
                add_bcc_string  (&bcc_struct,   DEFAULT_DOMAIN);        // Bogus domain.

        add_bcc_string  (&bcc_struct,   DEFAULT_NATOS);                 // Native-OS.
        add_bcc_string  (&bcc_struct,   DEFAULT_LANMAN);                // Native Lan Manager.
        add_bcc_string  (&bcc_struct,   DEFAULT_PDOMAIN);               // Primary Domain.

        if (send_packet(session, SMBsesssetupX, wct_struct.count, wct_struct.data, bcc_struct.count, bcc_struct.data) < 0)
                return -1;

        free_bcc_struct(&bcc_struct);
        free_wct_struct(&wct_struct);

        if (recv_packet(session, SMBsesssetupX) < 0)
                return -1;

        if ((session->bcc_length != 0) && (session->bcc_data)) {
                parse_native_information(session, session->bcc_data, session->bcc_length);
        }

        free_data_session(session);

        return 0;
}

int
session_setup_request_NTLMSSP(struct SMB_session *session)
{
        struct bcc_struct bcc_struct;
        struct wct_struct wct_struct;

        init_bcc_struct(&bcc_struct);
        init_wct_struct(&wct_struct);

        session->flags  = 0x18;
        session->flags2 = 0x4807;

        add_wct_uint16_t(&wct_struct,   0xff);                          // AndXCommand, no more commands.
        add_wct_uint16_t(&wct_struct,   0);                             // andXOffset.
        add_wct_uint16_t(&wct_struct,   1024);                          // maxBufferCount.
        add_wct_uint16_t(&wct_struct,   50);                            // maxMpxCount.
        add_wct_uint16_t(&wct_struct,   0);                             // setup_new_vc_session.
        add_wct_uint32_t(&wct_struct,   0);                             // Session-key.
        add_wct_uint16_t(&wct_struct,   32);                            // Blob length
        add_wct_uint32_t(&wct_struct,   0);                             // Reserved
        add_wct_uint32_t(&wct_struct,   0x800000d4);                    // Capabilities
        
        add_bcc_string          (&bcc_struct, "NTLMSSP");               // indentifier
        add_bcc_uint32_t        (&bcc_struct, NTLMSSP_NEGOTIATE);       // type
        add_bcc_uint32_t        (&bcc_struct, 0xe0088297);              // flags
        add_bcc_uint32_t        (&bcc_struct, 0);                       // domain
        add_bcc_uint32_t        (&bcc_struct, 0);                       // name
        add_bcc_uint32_t        (&bcc_struct, 0);               
        add_bcc_uint32_t        (&bcc_struct, 0);               
        add_bcc_string          (&bcc_struct, DEFAULT_NATOS);           // native OS
        add_bcc_string          (&bcc_struct, DEFAULT_LANMAN);          // native LAN

        if (send_packet(session, SMBsesssetupX, wct_struct.count, wct_struct.data, bcc_struct.count, bcc_struct.data) < 0)
                return -1;

        free_bcc_struct(&bcc_struct);
        free_wct_struct(&wct_struct);

        if (recv_packet(session, SMBsesssetupX) < 0)
                return -1;

        free_data_session(session);

        return 0;
}

int
session_setup_request_AUTH(struct SMB_session *session)
{
        struct bcc_struct bcc_struct;
        struct wct_struct wct_struct;

        init_bcc_struct(&bcc_struct);
        init_wct_struct(&wct_struct);

        session->flags  = 0x18;
        session->flags2 = 0x4807;

        add_wct_uint16_t(&wct_struct,   0xff);                          // AndXCommand, no more commands.
        add_wct_uint16_t(&wct_struct,   0);                             // andXOffset.
        add_wct_uint16_t(&wct_struct,   1024);                          // maxBufferCount.
        add_wct_uint16_t(&wct_struct,   50);                            // maxMpxCount.
        add_wct_uint16_t(&wct_struct,   0);                             // setup_new_vc_session.
        add_wct_uint32_t(&wct_struct,   0);                             // Session-key.
        add_wct_uint16_t(&wct_struct,   87);                            // Blob length
        add_wct_uint32_t(&wct_struct,   0);                             // Reserved
        add_wct_uint32_t(&wct_struct,   0x800000d4);                    // Capabilities

        add_bcc_string          (&bcc_struct, "NTLMSSP");               // indentifier
        add_bcc_uint32_t        (&bcc_struct, NTLMSSP_AUTH);            // type
        add_bcc_uint16_t        (&bcc_struct, 1);                       // LANMAN Length        
        add_bcc_uint16_t        (&bcc_struct, 1);                       // LANMAN Maxlen        
        add_bcc_uint32_t        (&bcc_struct, 70);                      // LANMAN Offset        
        add_bcc_uint32_t        (&bcc_struct, 0);                       // NTLM Response
        add_bcc_uint32_t        (&bcc_struct, 0x47);
        add_bcc_uint32_t        (&bcc_struct, 0);                       // Domain name                  
        add_bcc_uint32_t        (&bcc_struct, 0x40);               
        add_bcc_uint32_t        (&bcc_struct, 0);                       // User name
        add_bcc_uint32_t        (&bcc_struct, 0x40);               
        add_bcc_uint16_t        (&bcc_struct, 6);                       // Hostname Length
        add_bcc_uint16_t        (&bcc_struct, 6);                       // Hostname Maxlen
        add_bcc_uint32_t        (&bcc_struct, 64);                      // Hostname Offset
        add_bcc_uint16_t        (&bcc_struct, 16);                      // Session Length
        add_bcc_uint16_t        (&bcc_struct, 16);                      // Session Maxlen
        add_bcc_uint32_t        (&bcc_struct, 71);                      // Session Offset
        add_bcc_uint32_t        (&bcc_struct, 0xe0888a15);              // Flags
        add_bcc_string          (&bcc_struct, HOST_NAME);

        add_bcc_uint32_t        (&bcc_struct, 0xED412C27);              // session key
        add_bcc_uint32_t        (&bcc_struct, 0x8626D259);              // session key
        add_bcc_uint32_t        (&bcc_struct, 0xA0B35EAA);              // session key
        add_bcc_uint32_t        (&bcc_struct, 0x00886fc5);              // session key
        add_bcc_string          (&bcc_struct, DEFAULT_NATOS);           // native OS
        add_bcc_string          (&bcc_struct, DEFAULT_LANMAN);          // native LAN
        add_bcc_uint32_t        (&bcc_struct, 0);                       

        if (send_packet(session, SMBsesssetupX, wct_struct.count, wct_struct.data, bcc_struct.count, bcc_struct.data) < 0)
                return -1;

        free_bcc_struct(&bcc_struct);
        free_wct_struct(&wct_struct);

        if (recv_packet(session, SMBsesssetupX) < 0)
                return -1;

        if ((session->bcc_length != 0) && (session->bcc_data)) {
                parse_native_information(session, session->bcc_data, session->bcc_length);
        }

        free_data_session(session);

        return 0;
}

int
tree_connect_and_x_reply(struct SMB_session *session, u_char *service)
{
        struct bcc_struct bcc_struct;
        struct wct_struct wct_struct;

        init_bcc_struct(&bcc_struct);
        init_wct_struct(&wct_struct);

        session->flags  = 0;
        session->flags2 = 0;

        add_wct_uint16_t (&wct_struct,  0xff);          // AndXCommand, no more commands.
        add_wct_uint16_t (&wct_struct,  0x00);          // AndXoffset.
        add_wct_uint16_t (&wct_struct,  0x08);          // Flags.
        add_wct_uint16_t (&wct_struct,  0x00);          // Password length.
        
        add_bcc_string   (&bcc_struct,  service);
        add_bcc_string   (&bcc_struct,  "?????");

        if (send_packet(session, SMBtconX, wct_struct.count, wct_struct.data, bcc_struct.count, bcc_struct.data) < 0)
                return -1;

        free_bcc_struct(&bcc_struct);
        free_wct_struct(&wct_struct);

        if (recv_packet(session, SMBtconX) < 0)
                return -1;

        free_data_session(session);
        
        return 0;
}

int
nt_open_pipe(struct SMB_session *session, const char *pipe_name)
{
        struct bcc_struct bcc_struct;
        struct wct_struct wct_struct;

        init_bcc_struct(&bcc_struct);
        init_wct_struct(&wct_struct);

        add_wct_uint16_t (&wct_struct,  0xff);          // AndXCommand, no more commands.
        add_wct_uint16_t (&wct_struct,  0x00);          // AndXoffset.
        add_wct_uint8_t  (&wct_struct,  0x00);
        add_wct_uint8_t  (&wct_struct,  0x00);
        add_wct_uint8_t  (&wct_struct,  0x00);
        add_wct_uint32_t (&wct_struct,  0x00000016);    // Create flags.
        add_wct_uint32_t (&wct_struct,  0x00000000);    // Root FID.
        add_wct_uint32_t (&wct_struct,  0x0002019f);    // Access Mask.
        add_wct_uint32_t (&wct_struct,  0x00000000);
        add_wct_uint32_t (&wct_struct,  0x00000000);    // Allocation size.
        add_wct_uint32_t (&wct_struct,  0x00000000);    // File attributes.
        add_wct_uint32_t (&wct_struct,  0x00000003);    // Share access.
        add_wct_uint32_t (&wct_struct,  0x00000001);    // Disposition: Open
        add_wct_uint32_t (&wct_struct,  0x00400040);    // Create Options.
        add_wct_uint8_t  (&wct_struct,  0x00);

        *(wct_struct.data + 5) = strlen(pipe_name);

        add_bcc_string   (&bcc_struct, (char *)pipe_name);      
        
        if (send_packet(session, SMBntcreateX, wct_struct.count, wct_struct.data, bcc_struct.count, bcc_struct.data) < 0)
                return -1;

        free_bcc_struct(&bcc_struct);
        free_wct_struct(&wct_struct);

        if (recv_packet(session, SMBntcreateX) < 0)
                return -1;

        if ((!session->wct_length) || (!session->wct_data)) {
                free_data_session(session);
                return -1;
        }

        if (parse_pipe_handle(session, session->wct_data, session->wct_length) < 0) {
                free_data_session(session);
                return -1;
        }

        free_data_session(session);

        return 0;
}

int
do_trans(struct SMB_session *session, char *data, size_t length, u_char *transname, u_int16_t option)
{
        struct bcc_struct bcc_struct;
        struct wct_struct wct_struct;

        unsigned int i = 0;

        init_bcc_struct(&bcc_struct);
        init_wct_struct(&wct_struct);

        add_wct_uint16_t (&wct_struct,  0);             // Total parameter count.       
        add_wct_uint16_t (&wct_struct,  length);        // Total data count.
        add_wct_uint16_t (&wct_struct,  0);             // Max parameter count.
        add_wct_uint16_t (&wct_struct,  1024);          // Max data count.
        add_wct_uint16_t (&wct_struct,  0);             // Max setup count.
        add_wct_uint16_t (&wct_struct,  0);             // Flags
        add_wct_uint32_t (&wct_struct,  0);             // Timeout
        add_wct_uint16_t (&wct_struct,  0);
        add_wct_uint16_t (&wct_struct,  0);             // Parameter count.
        add_wct_uint16_t (&wct_struct,  0);             // Parameter offset.
        add_wct_uint16_t (&wct_struct,  length);        // Data count.
        add_wct_uint16_t (&wct_struct,  74);            // Data offset.
        add_wct_uint16_t (&wct_struct,  2);             // Setup count.
        add_wct_uint8_t  (&wct_struct,  0);
        add_wct_uint8_t  (&wct_struct,  0);
        
        add_bcc_string   (&bcc_struct, transname);

        for (i = 0; i < length; i++) {
                add_bcc_uint8_t  (&bcc_struct, *(data + i));
        }       

        if (transname) {

                /* FIXME! Ugliness :) */

                *(wct_struct.data + 28) = option & 0xff;
                *(wct_struct.data + 29) = (option >> 8) & 0xff;

                *(wct_struct.data + 30) = session->pipe_handle & 0xff;
                *(wct_struct.data + 31) = (session->pipe_handle >> 8) & 0xff;
        }
        
        if (send_packet(session, SMBtrans, wct_struct.count, wct_struct.data, bcc_struct.count, bcc_struct.data) < 0)
                return -1;

        free_bcc_struct(&bcc_struct);
        free_wct_struct(&wct_struct);

        if (recv_packet(session, SMBtrans) < 0)
                return -1;

        free_data_session(session);

        return 0;
}

int
do_trans_RAP(struct SMB_session *session, char *data, size_t length)
{
        struct bcc_struct bcc_struct;
        struct wct_struct wct_struct;

        unsigned int i = 0;

        init_bcc_struct(&bcc_struct);
        init_wct_struct(&wct_struct);

        add_wct_uint16_t (&wct_struct,  1080);          // Total parameter count.
        add_wct_uint16_t (&wct_struct,  256);           // Total data count.
        add_wct_uint16_t (&wct_struct,  1024);          // Max parameter count.
        add_wct_uint16_t (&wct_struct,  2000);          // Max data count.
        add_wct_uint16_t (&wct_struct,  255);           // Max setup count.
        add_wct_uint16_t (&wct_struct,  0);             // Flags
        add_wct_uint32_t (&wct_struct,  0);             // Timeout
        add_wct_uint16_t (&wct_struct,  0);
        add_wct_uint16_t (&wct_struct,  1080);          // Parameter count.
        add_wct_uint16_t (&wct_struct,  80);            // Parameter offset.
        add_wct_uint16_t (&wct_struct,  256);           // Data count.
        add_wct_uint16_t (&wct_struct,  2000);          // Data offset.
        add_wct_uint16_t (&wct_struct,  2);             // Setup count.
        add_wct_uint8_t  (&wct_struct,  0);
        add_wct_uint8_t  (&wct_struct,  0);

        *(wct_struct.data + 30) = session->pipe_handle & 0xff;
        *(wct_struct.data + 31) = (session->pipe_handle >> 8) & 0xff;

        add_bcc_string   (&bcc_struct, "\\PIPE\\LANMAN");

        for (i = 0; i < length; i++) {
                add_bcc_uint8_t  (&bcc_struct, *(data + i));
        }

        if (send_packet(session, SMBtrans, wct_struct.count, wct_struct.data, bcc_struct.count, bcc_struct.data) < 0) {
                return -1;
        }

        if (recv_packet(session, SMBtrans) < 0) {
                return -1;
        }

        if ((!session->bcc_length) || (!session->bcc_data)) {
                free_data_session(session);
                return -1;
        }

        if (parse_share_comment(session, session->bcc_data, session->bcc_length) < 0) {
                free_data_session(session);
                return -1;
        }

        free_data_session(session);

        free_bcc_struct(&bcc_struct);
        free_wct_struct(&wct_struct);

        return 0;
}
