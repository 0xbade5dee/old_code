#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <math.h>

#include "cidr.h"

/* CIDR routines ripped from modular <modular@truncode.org> */

unsigned long
cidr_convert_ip(const char *t_addr)
{
        unsigned int octet1 = 0;
        unsigned int octet2 = 0;
        unsigned int octet3 = 0;
        unsigned int octet4 = 0;

        if (sscanf(t_addr, "%u.%u.%u.%u", &octet1, &octet2, &octet3, &octet4) < 1) {
                fprintf(stderr, "cidr_convert_ip: Not a standard IPv4 IP address.\n");
                exit(EXIT_FAILURE);
        }

        return((octet1 << 24) | (octet2 << 16) | (octet3 << 8) | octet4);
}

unsigned
long cidr_add_masking(const char *t_addr, int mask)
{
        if (mask > 32 || mask < 0) {
                fprintf(stderr, "add_masking: Not a valid subnet mask.\n");
                exit(EXIT_FAILURE);
        }

        return((unsigned long)pow(2, 32 - mask) + cidr_convert_ip(t_addr) -1);
}

unsigned char *
cidr_reverse_int(unsigned long addr)
{
        unsigned char *ptr = (unsigned char *)malloc(128);

        if (!ptr) {
                perror("malloc");
                exit(EXIT_FAILURE);
        }

        snprintf(ptr, 128, "%u.%u.%u.%u",
                (unsigned int)(addr & 0xff000000) >> 24,
                (unsigned int)(addr & 0x00ff0000) >> 16,
                (unsigned int)(addr & 0x0000ff00) >> 8,
                (unsigned int)(addr & 0x000000ff));

        return ptr;
}


